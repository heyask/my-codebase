"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@iconify";
exports.ids = ["vendor-chunks/@iconify"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@iconify/react/dist/iconify.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@iconify/react/dist/iconify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   InlineIcon: () => (/* binding */ InlineIcon),\n/* harmony export */   _api: () => (/* binding */ _api),\n/* harmony export */   addAPIProvider: () => (/* binding */ addAPIProvider),\n/* harmony export */   addCollection: () => (/* binding */ addCollection),\n/* harmony export */   addIcon: () => (/* binding */ addIcon),\n/* harmony export */   buildIcon: () => (/* binding */ iconToSVG),\n/* harmony export */   calculateSize: () => (/* binding */ calculateSize),\n/* harmony export */   disableCache: () => (/* binding */ disableCache),\n/* harmony export */   enableCache: () => (/* binding */ enableCache),\n/* harmony export */   getIcon: () => (/* binding */ getIcon),\n/* harmony export */   iconExists: () => (/* binding */ iconLoaded),\n/* harmony export */   iconLoaded: () => (/* binding */ iconLoaded),\n/* harmony export */   listIcons: () => (/* binding */ listIcons),\n/* harmony export */   loadIcon: () => (/* binding */ loadIcon),\n/* harmony export */   loadIcons: () => (/* binding */ loadIcons),\n/* harmony export */   replaceIDs: () => (/* binding */ replaceIDs),\n/* harmony export */   setCustomIconLoader: () => (/* binding */ setCustomIconLoader),\n/* harmony export */   setCustomIconsLoader: () => (/* binding */ setCustomIconsLoader)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ Icon,InlineIcon,_api,addAPIProvider,addCollection,addIcon,buildIcon,calculateSize,disableCache,enableCache,getIcon,iconExists,iconLoaded,listIcons,loadIcon,loadIcons,replaceIDs,setCustomIconLoader,setCustomIconsLoader auto */ \nconst defaultIconDimensions = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n});\nconst defaultIconTransformations = Object.freeze({\n    rotate: 0,\n    vFlip: false,\n    hFlip: false\n});\nconst defaultIconProps = Object.freeze({\n    ...defaultIconDimensions,\n    ...defaultIconTransformations\n});\nconst defaultExtendedIconProps = Object.freeze({\n    ...defaultIconProps,\n    body: \"\",\n    hidden: false\n});\nfunction mergeIconTransformations(obj1, obj2) {\n    const result = {};\n    if (!obj1.hFlip !== !obj2.hFlip) {\n        result.hFlip = true;\n    }\n    if (!obj1.vFlip !== !obj2.vFlip) {\n        result.vFlip = true;\n    }\n    const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n    if (rotate) {\n        result.rotate = rotate;\n    }\n    return result;\n}\nfunction mergeIconData(parent, child) {\n    const result = mergeIconTransformations(parent, child);\n    for(const key in defaultExtendedIconProps){\n        if (key in defaultIconTransformations) {\n            if (key in parent && !(key in result)) {\n                result[key] = defaultIconTransformations[key];\n            }\n        } else if (key in child) {\n            result[key] = child[key];\n        } else if (key in parent) {\n            result[key] = parent[key];\n        }\n    }\n    return result;\n}\nfunction getIconsTree(data, names) {\n    const icons = data.icons;\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    const resolved = /* @__PURE__ */ Object.create(null);\n    function resolve(name) {\n        if (icons[name]) {\n            return resolved[name] = [];\n        }\n        if (!(name in resolved)) {\n            resolved[name] = null;\n            const parent = aliases[name] && aliases[name].parent;\n            const value = parent && resolve(parent);\n            if (value) {\n                resolved[name] = [\n                    parent\n                ].concat(value);\n            }\n        }\n        return resolved[name];\n    }\n    Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);\n    return resolved;\n}\nfunction internalGetIconData(data, name, tree) {\n    const icons = data.icons;\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    let currentProps = {};\n    function parse(name2) {\n        currentProps = mergeIconData(icons[name2] || aliases[name2], currentProps);\n    }\n    parse(name);\n    tree.forEach(parse);\n    return mergeIconData(data, currentProps);\n}\nfunction parseIconSet(data, callback) {\n    const names = [];\n    if (typeof data !== \"object\" || typeof data.icons !== \"object\") {\n        return names;\n    }\n    if (data.not_found instanceof Array) {\n        data.not_found.forEach((name)=>{\n            callback(name, null);\n            names.push(name);\n        });\n    }\n    const tree = getIconsTree(data);\n    for(const name in tree){\n        const item = tree[name];\n        if (item) {\n            callback(name, internalGetIconData(data, name, item));\n            names.push(name);\n        }\n    }\n    return names;\n}\nconst optionalPropertyDefaults = {\n    provider: \"\",\n    aliases: {},\n    not_found: {},\n    ...defaultIconDimensions\n};\nfunction checkOptionalProps(item, defaults) {\n    for(const prop in defaults){\n        if (prop in item && typeof item[prop] !== typeof defaults[prop]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction quicklyValidateIconSet(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return null;\n    }\n    const data = obj;\n    if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") {\n        return null;\n    }\n    if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n        return null;\n    }\n    const icons = data.icons;\n    for(const name in icons){\n        const icon = icons[name];\n        if (// Name cannot be empty\n        !name || // Must have body\n        typeof icon.body !== \"string\" || // Check other props\n        !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    for(const name in aliases){\n        const icon = aliases[name];\n        const parent = icon.parent;\n        if (// Name cannot be empty\n        !name || // Parent must be set and point to existing icon\n        typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || // Check other props\n        !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    return data;\n}\nconst matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nconst stringToIcon = (value, validate, allowSimpleName, provider = \"\")=>{\n    const colonSeparated = value.split(\":\");\n    if (value.slice(0, 1) === \"@\") {\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n            return null;\n        }\n        provider = colonSeparated.shift().slice(1);\n    }\n    if (colonSeparated.length > 3 || !colonSeparated.length) {\n        return null;\n    }\n    if (colonSeparated.length > 1) {\n        const name2 = colonSeparated.pop();\n        const prefix = colonSeparated.pop();\n        const result = {\n            // Allow provider without '@': \"provider:prefix:name\"\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix,\n            name: name2\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    const name = colonSeparated[0];\n    const dashSeparated = name.split(\"-\");\n    if (dashSeparated.length > 1) {\n        const result = {\n            provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join(\"-\")\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    if (allowSimpleName && provider === \"\") {\n        const result = {\n            provider,\n            prefix: \"\",\n            name\n        };\n        return validate && !validateIconName(result, allowSimpleName) ? null : result;\n    }\n    return null;\n};\nconst validateIconName = (icon, allowSimpleName)=>{\n    if (!icon) {\n        return false;\n    }\n    return !!// Check name: cannot be empty\n    ((allowSimpleName && icon.prefix === \"\" || !!icon.prefix) && !!icon.name);\n};\nconst dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n    return {\n        provider,\n        prefix,\n        icons: /* @__PURE__ */ Object.create(null),\n        missing: /* @__PURE__ */ new Set()\n    };\n}\nfunction getStorage(provider, prefix) {\n    const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n    if (!quicklyValidateIconSet(data)) {\n        return [];\n    }\n    return parseIconSet(data, (name, icon)=>{\n        if (icon) {\n            storage.icons[name] = icon;\n        } else {\n            storage.missing.add(name);\n        }\n    });\n}\nfunction addIconToStorage(storage, name, icon) {\n    try {\n        if (typeof icon.body === \"string\") {\n            storage.icons[name] = {\n                ...icon\n            };\n            return true;\n        }\n    } catch (err) {}\n    return false;\n}\nfunction listIcons(provider, prefix) {\n    let allIcons = [];\n    const providers = typeof provider === \"string\" ? [\n        provider\n    ] : Object.keys(dataStorage);\n    providers.forEach((provider2)=>{\n        const prefixes = typeof provider2 === \"string\" && typeof prefix === \"string\" ? [\n            prefix\n        ] : Object.keys(dataStorage[provider2] || {});\n        prefixes.forEach((prefix2)=>{\n            const storage = getStorage(provider2, prefix2);\n            allIcons = allIcons.concat(Object.keys(storage.icons).map((name)=>(provider2 !== \"\" ? \"@\" + provider2 + \":\" : \"\") + prefix2 + \":\" + name));\n        });\n    });\n    return allIcons;\n}\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n    if (typeof allow === \"boolean\") {\n        simpleNames = allow;\n    }\n    return simpleNames;\n}\nfunction getIconData(name) {\n    const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n    if (icon) {\n        const storage = getStorage(icon.provider, icon.prefix);\n        const iconName = icon.name;\n        return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n    }\n}\nfunction addIcon(name, data) {\n    const icon = stringToIcon(name, true, simpleNames);\n    if (!icon) {\n        return false;\n    }\n    const storage = getStorage(icon.provider, icon.prefix);\n    if (data) {\n        return addIconToStorage(storage, icon.name, data);\n    } else {\n        storage.missing.add(icon.name);\n        return true;\n    }\n}\nfunction addCollection(data, provider) {\n    if (typeof data !== \"object\") {\n        return false;\n    }\n    if (typeof provider !== \"string\") {\n        provider = data.provider || \"\";\n    }\n    if (simpleNames && !provider && !data.prefix) {\n        let added = false;\n        if (quicklyValidateIconSet(data)) {\n            data.prefix = \"\";\n            parseIconSet(data, (name, icon)=>{\n                if (addIcon(name, icon)) {\n                    added = true;\n                }\n            });\n        }\n        return added;\n    }\n    const prefix = data.prefix;\n    if (!validateIconName({\n        prefix,\n        name: \"a\"\n    })) {\n        return false;\n    }\n    const storage = getStorage(provider, prefix);\n    return !!addIconSet(storage, data);\n}\nfunction iconLoaded(name) {\n    return !!getIconData(name);\n}\nfunction getIcon(name) {\n    const result = getIconData(name);\n    return result ? {\n        ...defaultIconProps,\n        ...result\n    } : result;\n}\nconst defaultIconSizeCustomisations = Object.freeze({\n    width: null,\n    height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n    // Dimensions\n    ...defaultIconSizeCustomisations,\n    // Transformations\n    ...defaultIconTransformations\n});\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n    if (ratio === 1) {\n        return size;\n    }\n    precision = precision || 100;\n    if (typeof size === \"number\") {\n        return Math.ceil(size * ratio * precision) / precision;\n    }\n    if (typeof size !== \"string\") {\n        return size;\n    }\n    const oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) {\n        return size;\n    }\n    const newParts = [];\n    let code = oldParts.shift();\n    let isNumber = unitsTest.test(code);\n    while(true){\n        if (isNumber) {\n            const num = parseFloat(code);\n            if (isNaN(num)) {\n                newParts.push(code);\n            } else {\n                newParts.push(Math.ceil(num * ratio * precision) / precision);\n            }\n        } else {\n            newParts.push(code);\n        }\n        code = oldParts.shift();\n        if (code === void 0) {\n            return newParts.join(\"\");\n        }\n        isNumber = !isNumber;\n    }\n}\nfunction splitSVGDefs(content, tag = \"defs\") {\n    let defs = \"\";\n    const index = content.indexOf(\"<\" + tag);\n    while(index >= 0){\n        const start = content.indexOf(\">\", index);\n        const end = content.indexOf(\"</\" + tag);\n        if (start === -1 || end === -1) {\n            break;\n        }\n        const endEnd = content.indexOf(\">\", end);\n        if (endEnd === -1) {\n            break;\n        }\n        defs += content.slice(start + 1, end).trim();\n        content = content.slice(0, index).trim() + content.slice(endEnd + 1);\n    }\n    return {\n        defs,\n        content\n    };\n}\nfunction mergeDefsAndContent(defs, content) {\n    return defs ? \"<defs>\" + defs + \"</defs>\" + content : content;\n}\nfunction wrapSVGContent(body, start, end) {\n    const split = splitSVGDefs(body);\n    return mergeDefsAndContent(split.defs, start + split.content + end);\n}\nconst isUnsetKeyword = (value)=>value === \"unset\" || value === \"undefined\" || value === \"none\";\nfunction iconToSVG(icon, customisations) {\n    const fullIcon = {\n        ...defaultIconProps,\n        ...icon\n    };\n    const fullCustomisations = {\n        ...defaultIconCustomisations,\n        ...customisations\n    };\n    const box = {\n        left: fullIcon.left,\n        top: fullIcon.top,\n        width: fullIcon.width,\n        height: fullIcon.height\n    };\n    let body = fullIcon.body;\n    [\n        fullIcon,\n        fullCustomisations\n    ].forEach((props)=>{\n        const transformations = [];\n        const hFlip = props.hFlip;\n        const vFlip = props.vFlip;\n        let rotation = props.rotate;\n        if (hFlip) {\n            if (vFlip) {\n                rotation += 2;\n            } else {\n                transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n                transformations.push(\"scale(-1 1)\");\n                box.top = box.left = 0;\n            }\n        } else if (vFlip) {\n            transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n            transformations.push(\"scale(1 -1)\");\n            box.top = box.left = 0;\n        }\n        let tempValue;\n        if (rotation < 0) {\n            rotation -= Math.floor(rotation / 4) * 4;\n        }\n        rotation = rotation % 4;\n        switch(rotation){\n            case 1:\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n            case 2:\n                transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n                break;\n            case 3:\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n        }\n        if (rotation % 2 === 1) {\n            if (box.left !== box.top) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) {\n            body = wrapSVGContent(body, '<g transform=\"' + transformations.join(\" \") + '\">', \"</g>\");\n        }\n    });\n    const customisationsWidth = fullCustomisations.width;\n    const customisationsHeight = fullCustomisations.height;\n    const boxWidth = box.width;\n    const boxHeight = box.height;\n    let width;\n    let height;\n    if (customisationsWidth === null) {\n        height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n        width = calculateSize(height, boxWidth / boxHeight);\n    } else {\n        width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n        height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    }\n    const attributes = {};\n    const setAttr = (prop, value)=>{\n        if (!isUnsetKeyword(value)) {\n            attributes[prop] = value.toString();\n        }\n    };\n    setAttr(\"width\", width);\n    setAttr(\"height\", height);\n    const viewBox = [\n        box.left,\n        box.top,\n        boxWidth,\n        boxHeight\n    ];\n    attributes.viewBox = viewBox.join(\" \");\n    return {\n        attributes,\n        viewBox,\n        body\n    };\n}\nconst regex = /\\sid=\"(\\S+)\"/g;\nconst randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\nlet counter = 0;\nfunction replaceIDs(body, prefix = randomPrefix) {\n    const ids = [];\n    let match;\n    while(match = regex.exec(body)){\n        ids.push(match[1]);\n    }\n    if (!ids.length) {\n        return body;\n    }\n    const suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n    ids.forEach((id)=>{\n        const newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n        const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        body = body.replace(// Allowed characters before id: [#;\"]\n        // Allowed characters after id: [)\"], .[a-z]\n        new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"), \"$1\" + newID + suffix + \"$3\");\n    });\n    body = body.replace(new RegExp(suffix, \"g\"), \"\");\n    return body;\n}\nconst storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n    storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n    return storage[provider] || storage[\"\"];\n}\nfunction createAPIConfig(source) {\n    let resources;\n    if (typeof source.resources === \"string\") {\n        resources = [\n            source.resources\n        ];\n    } else {\n        resources = source.resources;\n        if (!(resources instanceof Array) || !resources.length) {\n            return null;\n        }\n    }\n    const result = {\n        // API hosts\n        resources,\n        // Root path\n        path: source.path || \"/\",\n        // URL length limit\n        maxURL: source.maxURL || 500,\n        // Timeout before next host is used.\n        rotate: source.rotate || 750,\n        // Timeout before failing query.\n        timeout: source.timeout || 5e3,\n        // Randomise default API end point.\n        random: source.random === true,\n        // Start index\n        index: source.index || 0,\n        // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n        dataAfterTimeout: source.dataAfterTimeout !== false\n    };\n    return result;\n}\nconst configStorage = /* @__PURE__ */ Object.create(null);\nconst fallBackAPISources = [\n    \"https://api.simplesvg.com\",\n    \"https://api.unisvg.com\"\n];\nconst fallBackAPI = [];\nwhile(fallBackAPISources.length > 0){\n    if (fallBackAPISources.length === 1) {\n        fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n        if (Math.random() > 0.5) {\n            fallBackAPI.push(fallBackAPISources.shift());\n        } else {\n            fallBackAPI.push(fallBackAPISources.pop());\n        }\n    }\n}\nconfigStorage[\"\"] = createAPIConfig({\n    resources: [\n        \"https://api.iconify.design\"\n    ].concat(fallBackAPI)\n});\nfunction addAPIProvider(provider, customConfig) {\n    const config = createAPIConfig(customConfig);\n    if (config === null) {\n        return false;\n    }\n    configStorage[provider] = config;\n    return true;\n}\nfunction getAPIConfig(provider) {\n    return configStorage[provider];\n}\nfunction listAPIProviders() {\n    return Object.keys(configStorage);\n}\nconst detectFetch = ()=>{\n    let callback;\n    try {\n        callback = fetch;\n        if (typeof callback === \"function\") {\n            return callback;\n        }\n    } catch (err) {}\n};\nlet fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n    fetchModule = fetch2;\n}\nfunction getFetch() {\n    return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n    const config = getAPIConfig(provider);\n    if (!config) {\n        return 0;\n    }\n    let result;\n    if (!config.maxURL) {\n        result = 0;\n    } else {\n        let maxHostLength = 0;\n        config.resources.forEach((item)=>{\n            const host = item;\n            maxHostLength = Math.max(maxHostLength, host.length);\n        });\n        const url = prefix + \".json?icons=\";\n        result = config.maxURL - maxHostLength - config.path.length - url.length;\n    }\n    return result;\n}\nfunction shouldAbort(status) {\n    return status === 404;\n}\nconst prepare = (provider, prefix, icons)=>{\n    const results = [];\n    const maxLength = calculateMaxLength(provider, prefix);\n    const type = \"icons\";\n    let item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n    };\n    let length = 0;\n    icons.forEach((name, index)=>{\n        length += name.length + 1;\n        if (length >= maxLength && index > 0) {\n            results.push(item);\n            item = {\n                type,\n                provider,\n                prefix,\n                icons: []\n            };\n            length = name.length;\n        }\n        item.icons.push(name);\n    });\n    results.push(item);\n    return results;\n};\nfunction getPath(provider) {\n    if (typeof provider === \"string\") {\n        const config = getAPIConfig(provider);\n        if (config) {\n            return config.path;\n        }\n    }\n    return \"/\";\n}\nconst send = (host, params, callback)=>{\n    if (!fetchModule) {\n        callback(\"abort\", 424);\n        return;\n    }\n    let path = getPath(params.provider);\n    switch(params.type){\n        case \"icons\":\n            {\n                const prefix = params.prefix;\n                const icons = params.icons;\n                const iconsList = icons.join(\",\");\n                const urlParams = new URLSearchParams({\n                    icons: iconsList\n                });\n                path += prefix + \".json?\" + urlParams.toString();\n                break;\n            }\n        case \"custom\":\n            {\n                const uri = params.uri;\n                path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n                break;\n            }\n        default:\n            callback(\"abort\", 400);\n            return;\n    }\n    let defaultError = 503;\n    fetchModule(host + path).then((response)=>{\n        const status = response.status;\n        if (status !== 200) {\n            setTimeout(()=>{\n                callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n            });\n            return;\n        }\n        defaultError = 501;\n        return response.json();\n    }).then((data)=>{\n        if (typeof data !== \"object\" || data === null) {\n            setTimeout(()=>{\n                if (data === 404) {\n                    callback(\"abort\", data);\n                } else {\n                    callback(\"next\", defaultError);\n                }\n            });\n            return;\n        }\n        setTimeout(()=>{\n            callback(\"success\", data);\n        });\n    }).catch(()=>{\n        callback(\"next\", defaultError);\n    });\n};\nconst fetchAPIModule = {\n    prepare,\n    send\n};\nfunction sortIcons(icons) {\n    const result = {\n        loaded: [],\n        missing: [],\n        pending: []\n    };\n    const storage = /* @__PURE__ */ Object.create(null);\n    icons.sort((a, b)=>{\n        if (a.provider !== b.provider) {\n            return a.provider.localeCompare(b.provider);\n        }\n        if (a.prefix !== b.prefix) {\n            return a.prefix.localeCompare(b.prefix);\n        }\n        return a.name.localeCompare(b.name);\n    });\n    let lastIcon = {\n        provider: \"\",\n        prefix: \"\",\n        name: \"\"\n    };\n    icons.forEach((icon)=>{\n        if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n            return;\n        }\n        lastIcon = icon;\n        const provider = icon.provider;\n        const prefix = icon.prefix;\n        const name = icon.name;\n        const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n        const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n        let list;\n        if (name in localStorage.icons) {\n            list = result.loaded;\n        } else if (prefix === \"\" || localStorage.missing.has(name)) {\n            list = result.missing;\n        } else {\n            list = result.pending;\n        }\n        const item = {\n            provider,\n            prefix,\n            name\n        };\n        list.push(item);\n    });\n    return result;\n}\nfunction removeCallback(storages, id) {\n    storages.forEach((storage)=>{\n        const items = storage.loaderCallbacks;\n        if (items) {\n            storage.loaderCallbacks = items.filter((row)=>row.id !== id);\n        }\n    });\n}\nfunction updateCallbacks(storage) {\n    if (!storage.pendingCallbacksFlag) {\n        storage.pendingCallbacksFlag = true;\n        setTimeout(()=>{\n            storage.pendingCallbacksFlag = false;\n            const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n            if (!items.length) {\n                return;\n            }\n            let hasPending = false;\n            const provider = storage.provider;\n            const prefix = storage.prefix;\n            items.forEach((item)=>{\n                const icons = item.icons;\n                const oldLength = icons.pending.length;\n                icons.pending = icons.pending.filter((icon)=>{\n                    if (icon.prefix !== prefix) {\n                        return true;\n                    }\n                    const name = icon.name;\n                    if (storage.icons[name]) {\n                        icons.loaded.push({\n                            provider,\n                            prefix,\n                            name\n                        });\n                    } else if (storage.missing.has(name)) {\n                        icons.missing.push({\n                            provider,\n                            prefix,\n                            name\n                        });\n                    } else {\n                        hasPending = true;\n                        return true;\n                    }\n                    return false;\n                });\n                if (icons.pending.length !== oldLength) {\n                    if (!hasPending) {\n                        removeCallback([\n                            storage\n                        ], item.id);\n                    }\n                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n                }\n            });\n        });\n    }\n}\nlet idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n    const id = idCounter++;\n    const abort = removeCallback.bind(null, pendingSources, id);\n    if (!icons.pending.length) {\n        return abort;\n    }\n    const item = {\n        id,\n        icons,\n        callback,\n        abort\n    };\n    pendingSources.forEach((storage)=>{\n        (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n    });\n    return abort;\n}\nfunction listToIcons(list, validate = true, simpleNames = false) {\n    const result = [];\n    list.forEach((item)=>{\n        const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n        if (icon) {\n            result.push(icon);\n        }\n    });\n    return result;\n}\n// src/config.ts\nvar defaultConfig = {\n    resources: [],\n    index: 0,\n    timeout: 2e3,\n    rotate: 750,\n    random: false,\n    dataAfterTimeout: false\n};\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n    const resourcesCount = config.resources.length;\n    const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n    let resources;\n    if (config.random) {\n        let list = config.resources.slice(0);\n        resources = [];\n        while(list.length > 1){\n            const nextIndex = Math.floor(Math.random() * list.length);\n            resources.push(list[nextIndex]);\n            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n        }\n        resources = resources.concat(list);\n    } else {\n        resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n    }\n    const startTime = Date.now();\n    let status = \"pending\";\n    let queriesSent = 0;\n    let lastError;\n    let timer = null;\n    let queue = [];\n    let doneCallbacks = [];\n    if (typeof done === \"function\") {\n        doneCallbacks.push(done);\n    }\n    function resetTimer() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }\n    function abort() {\n        if (status === \"pending\") {\n            status = \"aborted\";\n        }\n        resetTimer();\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function subscribe(callback, overwrite) {\n        if (overwrite) {\n            doneCallbacks = [];\n        }\n        if (typeof callback === \"function\") {\n            doneCallbacks.push(callback);\n        }\n    }\n    function getQueryStatus() {\n        return {\n            startTime,\n            payload,\n            status,\n            queriesSent,\n            queriesPending: queue.length,\n            subscribe,\n            abort\n        };\n    }\n    function failQuery() {\n        status = \"failed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(void 0, lastError);\n        });\n    }\n    function clearQueue() {\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function moduleResponse(item, response, data) {\n        const isError = response !== \"success\";\n        queue = queue.filter((queued)=>queued !== item);\n        switch(status){\n            case \"pending\":\n                break;\n            case \"failed\":\n                if (isError || !config.dataAfterTimeout) {\n                    return;\n                }\n                break;\n            default:\n                return;\n        }\n        if (response === \"abort\") {\n            lastError = data;\n            failQuery();\n            return;\n        }\n        if (isError) {\n            lastError = data;\n            if (!queue.length) {\n                if (!resources.length) {\n                    failQuery();\n                } else {\n                    execNext();\n                }\n            }\n            return;\n        }\n        resetTimer();\n        clearQueue();\n        if (!config.random) {\n            const index = config.resources.indexOf(item.resource);\n            if (index !== -1 && index !== config.index) {\n                config.index = index;\n            }\n        }\n        status = \"completed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(data);\n        });\n    }\n    function execNext() {\n        if (status !== \"pending\") {\n            return;\n        }\n        resetTimer();\n        const resource = resources.shift();\n        if (resource === void 0) {\n            if (queue.length) {\n                timer = setTimeout(()=>{\n                    resetTimer();\n                    if (status === \"pending\") {\n                        clearQueue();\n                        failQuery();\n                    }\n                }, config.timeout);\n                return;\n            }\n            failQuery();\n            return;\n        }\n        const item = {\n            status: \"pending\",\n            resource,\n            callback: (status2, data)=>{\n                moduleResponse(item, status2, data);\n            }\n        };\n        queue.push(item);\n        queriesSent++;\n        timer = setTimeout(execNext, config.rotate);\n        query(resource, payload, item.callback);\n    }\n    setTimeout(execNext);\n    return getQueryStatus;\n}\n// src/index.ts\nfunction initRedundancy(cfg) {\n    const config = {\n        ...defaultConfig,\n        ...cfg\n    };\n    let queries = [];\n    function cleanup() {\n        queries = queries.filter((item)=>item().status === \"pending\");\n    }\n    function query(payload, queryCallback, doneCallback) {\n        const query2 = sendQuery(config, payload, queryCallback, (data, error)=>{\n            cleanup();\n            if (doneCallback) {\n                doneCallback(data, error);\n            }\n        });\n        queries.push(query2);\n        return query2;\n    }\n    function find(callback) {\n        return queries.find((value)=>{\n            return callback(value);\n        }) || null;\n    }\n    const instance = {\n        query,\n        find,\n        setIndex: (index)=>{\n            config.index = index;\n        },\n        getIndex: ()=>config.index,\n        cleanup\n    };\n    return instance;\n}\nfunction emptyCallback$1() {}\nconst redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n    if (!redundancyCache[provider]) {\n        const config = getAPIConfig(provider);\n        if (!config) {\n            return;\n        }\n        const redundancy = initRedundancy(config);\n        const cachedReundancy = {\n            config,\n            redundancy\n        };\n        redundancyCache[provider] = cachedReundancy;\n    }\n    return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n    let redundancy;\n    let send;\n    if (typeof target === \"string\") {\n        const api = getAPIModule(target);\n        if (!api) {\n            callback(void 0, 424);\n            return emptyCallback$1;\n        }\n        send = api.send;\n        const cached = getRedundancyCache(target);\n        if (cached) {\n            redundancy = cached.redundancy;\n        }\n    } else {\n        const config = createAPIConfig(target);\n        if (config) {\n            redundancy = initRedundancy(config);\n            const moduleKey = target.resources ? target.resources[0] : \"\";\n            const api = getAPIModule(moduleKey);\n            if (api) {\n                send = api.send;\n            }\n        }\n    }\n    if (!redundancy || !send) {\n        callback(void 0, 424);\n        return emptyCallback$1;\n    }\n    return redundancy.query(query, send, callback)().abort;\n}\nfunction emptyCallback() {}\nfunction loadedNewIcons(storage) {\n    if (!storage.iconsLoaderFlag) {\n        storage.iconsLoaderFlag = true;\n        setTimeout(()=>{\n            storage.iconsLoaderFlag = false;\n            updateCallbacks(storage);\n        });\n    }\n}\nfunction checkIconNamesForAPI(icons) {\n    const valid = [];\n    const invalid = [];\n    icons.forEach((name)=>{\n        (name.match(matchIconName) ? valid : invalid).push(name);\n    });\n    return {\n        valid,\n        invalid\n    };\n}\nfunction parseLoaderResponse(storage, icons, data) {\n    function checkMissing() {\n        const pending = storage.pendingIcons;\n        icons.forEach((name)=>{\n            if (pending) {\n                pending.delete(name);\n            }\n            if (!storage.icons[name]) {\n                storage.missing.add(name);\n            }\n        });\n    }\n    if (data && typeof data === \"object\") {\n        try {\n            const parsed = addIconSet(storage, data);\n            if (!parsed.length) {\n                checkMissing();\n                return;\n            }\n        } catch (err) {\n            console.error(err);\n        }\n    }\n    checkMissing();\n    loadedNewIcons(storage);\n}\nfunction parsePossiblyAsyncResponse(response, callback) {\n    if (response instanceof Promise) {\n        response.then((data)=>{\n            callback(data);\n        }).catch(()=>{\n            callback(null);\n        });\n    } else {\n        callback(response);\n    }\n}\nfunction loadNewIcons(storage, icons) {\n    if (!storage.iconsToLoad) {\n        storage.iconsToLoad = icons;\n    } else {\n        storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n    }\n    if (!storage.iconsQueueFlag) {\n        storage.iconsQueueFlag = true;\n        setTimeout(()=>{\n            storage.iconsQueueFlag = false;\n            const { provider, prefix } = storage;\n            const icons2 = storage.iconsToLoad;\n            delete storage.iconsToLoad;\n            if (!icons2 || !icons2.length) {\n                return;\n            }\n            const customIconLoader = storage.loadIcon;\n            if (storage.loadIcons && (icons2.length > 1 || !customIconLoader)) {\n                parsePossiblyAsyncResponse(storage.loadIcons(icons2, prefix, provider), (data)=>{\n                    parseLoaderResponse(storage, icons2, data);\n                });\n                return;\n            }\n            if (customIconLoader) {\n                icons2.forEach((name)=>{\n                    const response = customIconLoader(name, prefix, provider);\n                    parsePossiblyAsyncResponse(response, (data)=>{\n                        const iconSet = data ? {\n                            prefix,\n                            icons: {\n                                [name]: data\n                            }\n                        } : null;\n                        parseLoaderResponse(storage, [\n                            name\n                        ], iconSet);\n                    });\n                });\n                return;\n            }\n            const { valid, invalid } = checkIconNamesForAPI(icons2);\n            if (invalid.length) {\n                parseLoaderResponse(storage, invalid, null);\n            }\n            if (!valid.length) {\n                return;\n            }\n            const api = prefix.match(matchIconName) ? getAPIModule(provider) : null;\n            if (!api) {\n                parseLoaderResponse(storage, valid, null);\n                return;\n            }\n            const params = api.prepare(provider, prefix, valid);\n            params.forEach((item)=>{\n                sendAPIQuery(provider, item, (data)=>{\n                    parseLoaderResponse(storage, item.icons, data);\n                });\n            });\n        });\n    }\n}\nconst loadIcons = (icons, callback)=>{\n    const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n    const sortedIcons = sortIcons(cleanedIcons);\n    if (!sortedIcons.pending.length) {\n        let callCallback = true;\n        if (callback) {\n            setTimeout(()=>{\n                if (callCallback) {\n                    callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n                }\n            });\n        }\n        return ()=>{\n            callCallback = false;\n        };\n    }\n    const newIcons = /* @__PURE__ */ Object.create(null);\n    const sources = [];\n    let lastProvider, lastPrefix;\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix } = icon;\n        if (prefix === lastPrefix && provider === lastProvider) {\n            return;\n        }\n        lastProvider = provider;\n        lastPrefix = prefix;\n        sources.push(getStorage(provider, prefix));\n        const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n        if (!providerNewIcons[prefix]) {\n            providerNewIcons[prefix] = [];\n        }\n    });\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix, name } = icon;\n        const storage = getStorage(provider, prefix);\n        const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n        if (!pendingQueue.has(name)) {\n            pendingQueue.add(name);\n            newIcons[provider][prefix].push(name);\n        }\n    });\n    sources.forEach((storage)=>{\n        const list = newIcons[storage.provider][storage.prefix];\n        if (list.length) {\n            loadNewIcons(storage, list);\n        }\n    });\n    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nconst loadIcon = (icon)=>{\n    return new Promise((fulfill, reject)=>{\n        const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n        if (!iconObj) {\n            reject(icon);\n            return;\n        }\n        loadIcons([\n            iconObj || icon\n        ], (loaded)=>{\n            if (loaded.length && iconObj) {\n                const data = getIconData(iconObj);\n                if (data) {\n                    fulfill({\n                        ...defaultIconProps,\n                        ...data\n                    });\n                    return;\n                }\n            }\n            reject(icon);\n        });\n    });\n};\nfunction setCustomIconsLoader(loader, prefix, provider) {\n    getStorage(provider || \"\", prefix).loadIcons = loader;\n}\nfunction setCustomIconLoader(loader, prefix, provider) {\n    getStorage(provider || \"\", prefix).loadIcon = loader;\n}\nfunction mergeCustomisations(defaults, item) {\n    const result = {\n        ...defaults\n    };\n    for(const key in item){\n        const value = item[key];\n        const valueType = typeof value;\n        if (key in defaultIconSizeCustomisations) {\n            if (value === null || value && (valueType === \"string\" || valueType === \"number\")) {\n                result[key] = value;\n            }\n        } else if (valueType === typeof result[key]) {\n            result[key] = key === \"rotate\" ? value % 4 : value;\n        }\n    }\n    return result;\n}\nconst separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n    flip.split(separator).forEach((str)=>{\n        const value = str.trim();\n        switch(value){\n            case \"horizontal\":\n                custom.hFlip = true;\n                break;\n            case \"vertical\":\n                custom.vFlip = true;\n                break;\n        }\n    });\n}\nfunction rotateFromString(value, defaultValue = 0) {\n    const units = value.replace(/^-?[0-9.]*/, \"\");\n    function cleanup(value2) {\n        while(value2 < 0){\n            value2 += 4;\n        }\n        return value2 % 4;\n    }\n    if (units === \"\") {\n        const num = parseInt(value);\n        return isNaN(num) ? 0 : cleanup(num);\n    } else if (units !== value) {\n        let split = 0;\n        switch(units){\n            case \"%\":\n                split = 25;\n                break;\n            case \"deg\":\n                split = 90;\n        }\n        if (split) {\n            let num = parseFloat(value.slice(0, value.length - units.length));\n            if (isNaN(num)) {\n                return 0;\n            }\n            num = num / split;\n            return num % 1 === 0 ? cleanup(num) : 0;\n        }\n    }\n    return defaultValue;\n}\nfunction iconToHTML(body, attributes) {\n    let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    for(const attr in attributes){\n        renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n    }\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\nfunction encodeSVGforURL(svg) {\n    return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n    return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n    return 'url(\"' + svgToData(svg) + '\")';\n}\nlet policy;\nfunction createPolicy() {\n    try {\n        policy = window.trustedTypes.createPolicy(\"iconify\", {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            createHTML: (s)=>s\n        });\n    } catch (err) {\n        policy = null;\n    }\n}\nfunction cleanUpInnerHTML(html) {\n    if (policy === void 0) {\n        createPolicy();\n    }\n    return policy ? policy.createHTML(html) : html;\n}\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false\n};\n/**\n * Default SVG attributes\n */ const svgDefaults = {\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"xmlnsXlink\": \"http://www.w3.org/1999/xlink\",\n    \"aria-hidden\": true,\n    \"role\": \"img\"\n};\n/**\n * Style modes\n */ const commonProps = {\n    display: \"inline-block\"\n};\nconst monotoneProps = {\n    backgroundColor: \"currentColor\"\n};\nconst coloredProps = {\n    backgroundColor: \"transparent\"\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    Image: \"var(--svg)\",\n    Repeat: \"no-repeat\",\n    Size: \"100% 100%\"\n};\nconst propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps\n};\nfor(const prefix in propsToAddTo){\n    const list = propsToAddTo[prefix];\n    for(const prop in propsToAdd){\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */ const inlineDefaults = {\n    ...defaultExtendedIconCustomisations,\n    inline: true\n};\n/**\n * Fix size: add 'px' to numbers\n */ function fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? \"px\" : \"\");\n}\n/**\n * Render icon\n */ const render = (// Icon must be validated before calling this function\nicon, // Partial properties\nprops, // Icon name\nname)=>{\n    // Get default properties\n    const defaultProps = props.inline ? inlineDefaults : defaultExtendedIconCustomisations;\n    // Get all customisations\n    const customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    const mode = props.mode || \"svg\";\n    // Create style\n    const style = {};\n    const customStyle = props.style || {};\n    // Create SVG component properties\n    const componentProps = {\n        ...mode === \"svg\" ? svgDefaults : {}\n    };\n    if (name) {\n        const iconName = stringToIcon(name, false, true);\n        if (iconName) {\n            const classNames = [\n                \"iconify\"\n            ];\n            const props = [\n                \"provider\",\n                \"prefix\"\n            ];\n            for (const prop of props){\n                if (iconName[prop]) {\n                    classNames.push(\"iconify--\" + iconName[prop]);\n                }\n            }\n            componentProps.className = classNames.join(\" \");\n        }\n    }\n    // Get element properties\n    for(let key in props){\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch(key){\n            // Properties to ignore\n            case \"icon\":\n            case \"style\":\n            case \"children\":\n            case \"onLoad\":\n            case \"mode\":\n            case \"ssr\":\n                break;\n            // Forward ref\n            case \"_ref\":\n                componentProps.ref = value;\n                break;\n            // Merge class names\n            case \"className\":\n                componentProps[key] = (componentProps[key] ? componentProps[key] + \" \" : \"\") + value;\n                break;\n            // Boolean attributes\n            case \"inline\":\n            case \"hFlip\":\n            case \"vFlip\":\n                customisations[key] = value === true || value === \"true\" || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case \"flip\":\n                if (typeof value === \"string\") {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case \"color\":\n                style.color = value;\n                break;\n            // Rotation as string\n            case \"rotate\":\n                if (typeof value === \"string\") {\n                    customisations[key] = rotateFromString(value);\n                } else if (typeof value === \"number\") {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case \"ariaHidden\":\n            case \"aria-hidden\":\n                if (value !== true && value !== \"true\") {\n                    delete componentProps[\"aria-hidden\"];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = \"-0.125em\";\n    }\n    if (mode === \"svg\") {\n        // Add style\n        componentProps.style = {\n            ...style,\n            ...customStyle\n        };\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === \"string\") {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, \"_\");\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? ()=>id + \"ID\" + localCounter++ : \"iconifyReact\"))\n        };\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", componentProps);\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === \"mask\" || (mode === \"bg\" ? false : body.indexOf(\"currentColor\") !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + \"\",\n        height: height + \"\"\n    });\n    // Generate style\n    componentProps.style = {\n        ...style,\n        \"--svg\": svgToURL(html),\n        \"width\": fixSize(renderAttribs.width),\n        \"height\": fixSize(renderAttribs.height),\n        ...commonProps,\n        ...useMask ? monotoneProps : coloredProps,\n        ...customStyle\n    };\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", componentProps);\n};\n/**\n * Enable cache\n *\n * @deprecated No longer used\n */ function enableCache(storage) {\n//\n}\n/**\n * Disable cache\n *\n * @deprecated No longer used\n */ function disableCache(storage) {\n//\n}\n/**\n * Initialise stuff\n */ // Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule(\"\", fetchAPIModule);\n/**\n * Browser stuff\n */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\nfunction IconComponent(props) {\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!!props.ssr);\n    const [abort, setAbort] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Get initial state\n    function getInitialState(mounted) {\n        if (mounted) {\n            const name = props.icon;\n            if (typeof name === \"object\") {\n                // Icon as object\n                return {\n                    name: \"\",\n                    data: name\n                };\n            }\n            const data = getIconData(name);\n            if (data) {\n                return {\n                    name,\n                    data\n                };\n            }\n        }\n        return {\n            name: \"\"\n        };\n    }\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getInitialState(!!props.ssr));\n    // Cancel loading\n    function cleanup() {\n        const callback = abort.callback;\n        if (callback) {\n            callback();\n            setAbort({});\n        }\n    }\n    // Change state if it is different\n    function changeState(newState) {\n        if (JSON.stringify(state) !== JSON.stringify(newState)) {\n            cleanup();\n            setState(newState);\n            return true;\n        }\n    }\n    // Update state\n    function updateState() {\n        var _a;\n        const name = props.icon;\n        if (typeof name === \"object\") {\n            // Icon as object\n            changeState({\n                name: \"\",\n                data: name\n            });\n            return;\n        }\n        // New icon or got icon data\n        const data = getIconData(name);\n        if (changeState({\n            name,\n            data\n        })) {\n            if (data === undefined) {\n                // Load icon, update state when done\n                const callback = loadIcons([\n                    name\n                ], updateState);\n                setAbort({\n                    callback\n                });\n            } else if (data) {\n                // Icon data is available: trigger onLoad callback if present\n                (_a = props.onLoad) === null || _a === void 0 ? void 0 : _a.call(props, name);\n            }\n        }\n    }\n    // Mounted state, cleanup for loader\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setMounted(true);\n        return cleanup;\n    }, []);\n    // Icon changed or component mounted\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (mounted) {\n            updateState();\n        }\n    }, [\n        props.icon,\n        mounted\n    ]);\n    // Render icon\n    const { name, data } = state;\n    if (!data) {\n        return props.children ? props.children : props.fallback ? props.fallback : /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {});\n    }\n    return render({\n        ...defaultIconProps,\n        ...data\n    }, props, name);\n}\n/**\n * Block icon\n *\n * @param props - Component properties\n */ const Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>IconComponent({\n        ...props,\n        _ref: ref\n    }));\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */ const InlineIcon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>IconComponent({\n        inline: true,\n        ...props,\n        _ref: ref\n    }));\n/**\n * Internal API\n */ const _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BpY29uaWZ5L3JlYWN0L2Rpc3QvaWNvbmlmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrUUFFdUU7QUFFdkUsTUFBTUksd0JBQXdCQyxPQUFPQyxNQUFNLENBQ3pDO0lBQ0VDLE1BQU07SUFDTkMsS0FBSztJQUNMQyxPQUFPO0lBQ1BDLFFBQVE7QUFDVjtBQUVGLE1BQU1DLDZCQUE2Qk4sT0FBT0MsTUFBTSxDQUFDO0lBQy9DTSxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsT0FBTztBQUNUO0FBQ0EsTUFBTUMsbUJBQW1CVixPQUFPQyxNQUFNLENBQUM7SUFDckMsR0FBR0YscUJBQXFCO0lBQ3hCLEdBQUdPLDBCQUEwQjtBQUMvQjtBQUNBLE1BQU1LLDJCQUEyQlgsT0FBT0MsTUFBTSxDQUFDO0lBQzdDLEdBQUdTLGdCQUFnQjtJQUNuQkUsTUFBTTtJQUNOQyxRQUFRO0FBQ1Y7QUFFQSxTQUFTQyx5QkFBeUJDLElBQUksRUFBRUMsSUFBSTtJQUMxQyxNQUFNQyxTQUFTLENBQUM7SUFDaEIsSUFBSSxDQUFDRixLQUFLTixLQUFLLEtBQUssQ0FBQ08sS0FBS1AsS0FBSyxFQUFFO1FBQy9CUSxPQUFPUixLQUFLLEdBQUc7SUFDakI7SUFDQSxJQUFJLENBQUNNLEtBQUtQLEtBQUssS0FBSyxDQUFDUSxLQUFLUixLQUFLLEVBQUU7UUFDL0JTLE9BQU9ULEtBQUssR0FBRztJQUNqQjtJQUNBLE1BQU1ELFNBQVMsQ0FBQyxDQUFDUSxLQUFLUixNQUFNLElBQUksS0FBTVMsQ0FBQUEsS0FBS1QsTUFBTSxJQUFJLEVBQUMsSUFBSztJQUMzRCxJQUFJQSxRQUFRO1FBQ1ZVLE9BQU9WLE1BQU0sR0FBR0E7SUFDbEI7SUFDQSxPQUFPVTtBQUNUO0FBRUEsU0FBU0MsY0FBY0MsTUFBTSxFQUFFQyxLQUFLO0lBQ2xDLE1BQU1ILFNBQVNILHlCQUF5QkssUUFBUUM7SUFDaEQsSUFBSyxNQUFNQyxPQUFPVix5QkFB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LEdBQUdHLElBQUksQ0FBQ3JSLE9BQU92RztZQUM1RTtRQUNKO0lBQ0o7SUFDQSxvQ0FBb0M7SUFDcENoQyxnREFBU0EsQ0FBQztRQUNOOFksV0FBVztRQUNYLE9BQU9oSTtJQUNYLEdBQUcsRUFBRTtJQUNMLG9DQUFvQztJQUNwQzlRLGdEQUFTQSxDQUFDO1FBQ04sSUFBSTZZLFNBQVM7WUFDVFc7UUFDSjtJQUNKLEdBQUc7UUFBQ2pSLE1BQU0vRSxJQUFJO1FBQUVxVjtLQUFRO0lBQ3hCLGNBQWM7SUFDZCxNQUFNLEVBQUU3VyxJQUFJLEVBQUVQLElBQUksRUFBRSxHQUFHeVg7SUFDdkIsSUFBSSxDQUFDelgsTUFBTTtRQUNQLE9BQU84RyxNQUFNc1IsUUFBUSxHQUNmdFIsTUFBTXNSLFFBQVEsR0FDZHRSLE1BQU11UixRQUFRLEdBQ1Z2UixNQUFNdVIsUUFBUSxpQkFDZGphLG9EQUFhQSxDQUFDLFFBQVEsQ0FBQztJQUNyQztJQUNBLE9BQU9zWCxPQUFPO1FBQ1YsR0FBR3ZXLGdCQUFnQjtRQUNuQixHQUFHYSxJQUFJO0lBQ1gsR0FBRzhHLE9BQU92RztBQUNkO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU0rWCxxQkFBT2phLGlEQUFVQSxDQUFDLENBQUN5SSxPQUFPb1AsTUFBUWlCLGNBQWM7UUFDbEQsR0FBR3JRLEtBQUs7UUFDUnlSLE1BQU1yQztJQUNWO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU1zQywyQkFBYW5hLGlEQUFVQSxDQUFDLENBQUN5SSxPQUFPb1AsTUFBUWlCLGNBQWM7UUFDeEQxQyxRQUFRO1FBQ1IsR0FBRzNOLEtBQUs7UUFDUnlSLE1BQU1yQztJQUNWO0FBQ0E7O0NBRUMsR0FDRCxNQUFNdUMsT0FBTztJQUNUOU87SUFDQWY7SUFDQXVIO0lBQ0FuRztJQUNBRTtJQUNBTjtBQUNKO0FBRWtSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AaWNvbmlmeS9yZWFjdC9kaXN0L2ljb25pZnkuanM/MWQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGZvcndhcmRSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IGRlZmF1bHRJY29uRGltZW5zaW9ucyA9IE9iamVjdC5mcmVlemUoXG4gIHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICB3aWR0aDogMTYsXG4gICAgaGVpZ2h0OiAxNlxuICB9XG4pO1xuY29uc3QgZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgcm90YXRlOiAwLFxuICB2RmxpcDogZmFsc2UsXG4gIGhGbGlwOiBmYWxzZVxufSk7XG5jb25zdCBkZWZhdWx0SWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLmRlZmF1bHRJY29uRGltZW5zaW9ucyxcbiAgLi4uZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gIGJvZHk6IFwiXCIsXG4gIGhpZGRlbjogZmFsc2Vcbn0pO1xuXG5mdW5jdGlvbiBtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMob2JqMSwgb2JqMikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgaWYgKCFvYmoxLmhGbGlwICE9PSAhb2JqMi5oRmxpcCkge1xuICAgIHJlc3VsdC5oRmxpcCA9IHRydWU7XG4gIH1cbiAgaWYgKCFvYmoxLnZGbGlwICE9PSAhb2JqMi52RmxpcCkge1xuICAgIHJlc3VsdC52RmxpcCA9IHRydWU7XG4gIH1cbiAgY29uc3Qgcm90YXRlID0gKChvYmoxLnJvdGF0ZSB8fCAwKSArIChvYmoyLnJvdGF0ZSB8fCAwKSkgJSA0O1xuICBpZiAocm90YXRlKSB7XG4gICAgcmVzdWx0LnJvdGF0ZSA9IHJvdGF0ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtZXJnZUljb25EYXRhKHBhcmVudCwgY2hpbGQpIHtcbiAgY29uc3QgcmVzdWx0ID0gbWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zKHBhcmVudCwgY2hpbGQpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMpIHtcbiAgICBpZiAoa2V5IGluIGRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICBpZiAoa2V5IGluIHBhcmVudCAmJiAhKGtleSBpbiByZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSBpbiBjaGlsZCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBjaGlsZFtrZXldO1xuICAgIH0gZWxzZSBpZiAoa2V5IGluIHBhcmVudCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0SWNvbnNUcmVlKGRhdGEsIG5hbWVzKSB7XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZnVuY3Rpb24gcmVzb2x2ZShuYW1lKSB7XG4gICAgaWYgKGljb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRbbmFtZV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKCEobmFtZSBpbiByZXNvbHZlZCkpIHtcbiAgICAgIHJlc29sdmVkW25hbWVdID0gbnVsbDtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGFsaWFzZXNbbmFtZV0gJiYgYWxpYXNlc1tuYW1lXS5wYXJlbnQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcmVudCAmJiByZXNvbHZlKHBhcmVudCk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZWRbbmFtZV0gPSBbcGFyZW50XS5jb25jYXQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRbbmFtZV07XG4gIH1cbiAgKE9iamVjdC5rZXlzKGljb25zKS5jb25jYXQoT2JqZWN0LmtleXMoYWxpYXNlcykpKS5mb3JFYWNoKHJlc29sdmUpO1xuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SWNvbkRhdGEoZGF0YSwgbmFtZSwgdHJlZSkge1xuICBjb25zdCBpY29ucyA9IGRhdGEuaWNvbnM7XG4gIGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBjdXJyZW50UHJvcHMgPSB7fTtcbiAgZnVuY3Rpb24gcGFyc2UobmFtZTIpIHtcbiAgICBjdXJyZW50UHJvcHMgPSBtZXJnZUljb25EYXRhKFxuICAgICAgaWNvbnNbbmFtZTJdIHx8IGFsaWFzZXNbbmFtZTJdLFxuICAgICAgY3VycmVudFByb3BzXG4gICAgKTtcbiAgfVxuICBwYXJzZShuYW1lKTtcbiAgdHJlZS5mb3JFYWNoKHBhcnNlKTtcbiAgcmV0dXJuIG1lcmdlSWNvbkRhdGEoZGF0YSwgY3VycmVudFByb3BzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VJY29uU2V0KGRhdGEsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IG5hbWVzID0gW107XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZGF0YS5pY29ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBuYW1lcztcbiAgfVxuICBpZiAoZGF0YS5ub3RfZm91bmQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGRhdGEubm90X2ZvdW5kLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGNhbGxiYWNrKG5hbWUsIG51bGwpO1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCB0cmVlID0gZ2V0SWNvbnNUcmVlKGRhdGEpO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdHJlZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0cmVlW25hbWVdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjYWxsYmFjayhuYW1lLCBpbnRlcm5hbEdldEljb25EYXRhKGRhdGEsIG5hbWUsIGl0ZW0pKTtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lcztcbn1cblxuY29uc3Qgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzID0ge1xuICBwcm92aWRlcjogXCJcIixcbiAgYWxpYXNlczoge30sXG4gIG5vdF9mb3VuZDoge30sXG4gIC4uLmRlZmF1bHRJY29uRGltZW5zaW9uc1xufTtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9uYWxQcm9wcyhpdGVtLCBkZWZhdWx0cykge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAocHJvcCBpbiBpdGVtICYmIHR5cGVvZiBpdGVtW3Byb3BdICE9PSB0eXBlb2YgZGVmYXVsdHNbcHJvcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBxdWlja2x5VmFsaWRhdGVJY29uU2V0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkYXRhID0gb2JqO1xuICBpZiAodHlwZW9mIGRhdGEucHJlZml4ICE9PSBcInN0cmluZ1wiIHx8ICFvYmouaWNvbnMgfHwgdHlwZW9mIG9iai5pY29ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2hlY2tPcHRpb25hbFByb3BzKG9iaiwgb3B0aW9uYWxQcm9wZXJ0eURlZmF1bHRzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgZm9yIChjb25zdCBuYW1lIGluIGljb25zKSB7XG4gICAgY29uc3QgaWNvbiA9IGljb25zW25hbWVdO1xuICAgIGlmIChcbiAgICAgIC8vIE5hbWUgY2Fubm90IGJlIGVtcHR5XG4gICAgICAhbmFtZSB8fCAvLyBNdXN0IGhhdmUgYm9keVxuICAgICAgdHlwZW9mIGljb24uYm9keSAhPT0gXCJzdHJpbmdcIiB8fCAvLyBDaGVjayBvdGhlciBwcm9wc1xuICAgICAgIWNoZWNrT3B0aW9uYWxQcm9wcyhcbiAgICAgICAgaWNvbixcbiAgICAgICAgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBuYW1lIGluIGFsaWFzZXMpIHtcbiAgICBjb25zdCBpY29uID0gYWxpYXNlc1tuYW1lXTtcbiAgICBjb25zdCBwYXJlbnQgPSBpY29uLnBhcmVudDtcbiAgICBpZiAoXG4gICAgICAvLyBOYW1lIGNhbm5vdCBiZSBlbXB0eVxuICAgICAgIW5hbWUgfHwgLy8gUGFyZW50IG11c3QgYmUgc2V0IGFuZCBwb2ludCB0byBleGlzdGluZyBpY29uXG4gICAgICB0eXBlb2YgcGFyZW50ICE9PSBcInN0cmluZ1wiIHx8ICFpY29uc1twYXJlbnRdICYmICFhbGlhc2VzW3BhcmVudF0gfHwgLy8gQ2hlY2sgb3RoZXIgcHJvcHNcbiAgICAgICFjaGVja09wdGlvbmFsUHJvcHMoXG4gICAgICAgIGljb24sXG4gICAgICAgIGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wc1xuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5jb25zdCBtYXRjaEljb25OYW1lID0gL15bYS16MC05XSsoLVthLXowLTldKykqJC87XG5jb25zdCBzdHJpbmdUb0ljb24gPSAodmFsdWUsIHZhbGlkYXRlLCBhbGxvd1NpbXBsZU5hbWUsIHByb3ZpZGVyID0gXCJcIikgPT4ge1xuICBjb25zdCBjb2xvblNlcGFyYXRlZCA9IHZhbHVlLnNwbGl0KFwiOlwiKTtcbiAgaWYgKHZhbHVlLnNsaWNlKDAsIDEpID09PSBcIkBcIikge1xuICAgIGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPCAyIHx8IGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwcm92aWRlciA9IGNvbG9uU2VwYXJhdGVkLnNoaWZ0KCkuc2xpY2UoMSk7XG4gIH1cbiAgaWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDMgfHwgIWNvbG9uU2VwYXJhdGVkLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgbmFtZTIgPSBjb2xvblNlcGFyYXRlZC5wb3AoKTtcbiAgICBjb25zdCBwcmVmaXggPSBjb2xvblNlcGFyYXRlZC5wb3AoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAvLyBBbGxvdyBwcm92aWRlciB3aXRob3V0ICdAJzogXCJwcm92aWRlcjpwcmVmaXg6bmFtZVwiXG4gICAgICBwcm92aWRlcjogY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMCA/IGNvbG9uU2VwYXJhdGVkWzBdIDogcHJvdmlkZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBuYW1lOiBuYW1lMlxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb25OYW1lKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0O1xuICB9XG4gIGNvbnN0IG5hbWUgPSBjb2xvblNlcGFyYXRlZFswXTtcbiAgY29uc3QgZGFzaFNlcGFyYXRlZCA9IG5hbWUuc3BsaXQoXCItXCIpO1xuICBpZiAoZGFzaFNlcGFyYXRlZC5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBwcmVmaXg6IGRhc2hTZXBhcmF0ZWQuc2hpZnQoKSxcbiAgICAgIG5hbWU6IGRhc2hTZXBhcmF0ZWQuam9pbihcIi1cIilcbiAgICB9O1xuICAgIHJldHVybiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGVJY29uTmFtZShyZXN1bHQpID8gbnVsbCA6IHJlc3VsdDtcbiAgfVxuICBpZiAoYWxsb3dTaW1wbGVOYW1lICYmIHByb3ZpZGVyID09PSBcIlwiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgICByZXR1cm4gdmFsaWRhdGUgJiYgIXZhbGlkYXRlSWNvbk5hbWUocmVzdWx0LCBhbGxvd1NpbXBsZU5hbWUpID8gbnVsbCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCB2YWxpZGF0ZUljb25OYW1lID0gKGljb24sIGFsbG93U2ltcGxlTmFtZSkgPT4ge1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICEhLy8gQ2hlY2sgcHJlZml4OiBjYW5ub3QgYmUgZW1wdHksIHVubGVzcyBhbGxvd1NpbXBsZU5hbWUgaXMgZW5hYmxlZFxuICAvLyBDaGVjayBuYW1lOiBjYW5ub3QgYmUgZW1wdHlcbiAgKChhbGxvd1NpbXBsZU5hbWUgJiYgaWNvbi5wcmVmaXggPT09IFwiXCIgfHwgISFpY29uLnByZWZpeCkgJiYgISFpY29uLm5hbWUpO1xufTtcblxuY29uc3QgZGF0YVN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIG5ld1N0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkge1xuICByZXR1cm4ge1xuICAgIHByb3ZpZGVyLFxuICAgIHByZWZpeCxcbiAgICBpY29uczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgbWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSB7XG4gIGNvbnN0IHByb3ZpZGVyU3RvcmFnZSA9IGRhdGFTdG9yYWdlW3Byb3ZpZGVyXSB8fCAoZGF0YVN0b3JhZ2VbcHJvdmlkZXJdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICByZXR1cm4gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gbmV3U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG59XG5mdW5jdGlvbiBhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEpIHtcbiAgaWYgKCFxdWlja2x5VmFsaWRhdGVJY29uU2V0KGRhdGEpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBwYXJzZUljb25TZXQoZGF0YSwgKG5hbWUsIGljb24pID0+IHtcbiAgICBpZiAoaWNvbikge1xuICAgICAgc3RvcmFnZS5pY29uc1tuYW1lXSA9IGljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JhZ2UubWlzc2luZy5hZGQobmFtZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEljb25Ub1N0b3JhZ2Uoc3RvcmFnZSwgbmFtZSwgaWNvbikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgaWNvbi5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdG9yYWdlLmljb25zW25hbWVdID0geyAuLi5pY29uIH07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpc3RJY29ucyhwcm92aWRlciwgcHJlZml4KSB7XG4gIGxldCBhbGxJY29ucyA9IFtdO1xuICBjb25zdCBwcm92aWRlcnMgPSB0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIgPyBbcHJvdmlkZXJdIDogT2JqZWN0LmtleXMoZGF0YVN0b3JhZ2UpO1xuICBwcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXIyKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSB0eXBlb2YgcHJvdmlkZXIyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcmVmaXggPT09IFwic3RyaW5nXCIgPyBbcHJlZml4XSA6IE9iamVjdC5rZXlzKGRhdGFTdG9yYWdlW3Byb3ZpZGVyMl0gfHwge30pO1xuICAgIHByZWZpeGVzLmZvckVhY2goKHByZWZpeDIpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyMiwgcHJlZml4Mik7XG4gICAgICBhbGxJY29ucyA9IGFsbEljb25zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc3RvcmFnZS5pY29ucykubWFwKFxuICAgICAgICAgIChuYW1lKSA9PiAocHJvdmlkZXIyICE9PSBcIlwiID8gXCJAXCIgKyBwcm92aWRlcjIgKyBcIjpcIiA6IFwiXCIpICsgcHJlZml4MiArIFwiOlwiICsgbmFtZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbEljb25zO1xufVxuXG5sZXQgc2ltcGxlTmFtZXMgPSBmYWxzZTtcbmZ1bmN0aW9uIGFsbG93U2ltcGxlTmFtZXMoYWxsb3cpIHtcbiAgaWYgKHR5cGVvZiBhbGxvdyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBzaW1wbGVOYW1lcyA9IGFsbG93O1xuICB9XG4gIHJldHVybiBzaW1wbGVOYW1lcztcbn1cbmZ1bmN0aW9uIGdldEljb25EYXRhKG5hbWUpIHtcbiAgY29uc3QgaWNvbiA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKG5hbWUsIHRydWUsIHNpbXBsZU5hbWVzKSA6IG5hbWU7XG4gIGlmIChpY29uKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICAgIGNvbnN0IGljb25OYW1lID0gaWNvbi5uYW1lO1xuICAgIHJldHVybiBzdG9yYWdlLmljb25zW2ljb25OYW1lXSB8fCAoc3RvcmFnZS5taXNzaW5nLmhhcyhpY29uTmFtZSkgPyBudWxsIDogdm9pZCAwKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSWNvbihuYW1lLCBkYXRhKSB7XG4gIGNvbnN0IGljb24gPSBzdHJpbmdUb0ljb24obmFtZSwgdHJ1ZSwgc2ltcGxlTmFtZXMpO1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICBpZiAoZGF0YSkge1xuICAgIHJldHVybiBhZGRJY29uVG9TdG9yYWdlKHN0b3JhZ2UsIGljb24ubmFtZSwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RvcmFnZS5taXNzaW5nLmFkZChpY29uLm5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBhZGRDb2xsZWN0aW9uKGRhdGEsIHByb3ZpZGVyKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcHJvdmlkZXIgPSBkYXRhLnByb3ZpZGVyIHx8IFwiXCI7XG4gIH1cbiAgaWYgKHNpbXBsZU5hbWVzICYmICFwcm92aWRlciAmJiAhZGF0YS5wcmVmaXgpIHtcbiAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICBpZiAocXVpY2tseVZhbGlkYXRlSWNvblNldChkYXRhKSkge1xuICAgICAgZGF0YS5wcmVmaXggPSBcIlwiO1xuICAgICAgcGFyc2VJY29uU2V0KGRhdGEsIChuYW1lLCBpY29uKSA9PiB7XG4gICAgICAgIGlmIChhZGRJY29uKG5hbWUsIGljb24pKSB7XG4gICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGRhdGEucHJlZml4O1xuICBpZiAoIXZhbGlkYXRlSWNvbk5hbWUoe1xuICAgIHByZWZpeCxcbiAgICBuYW1lOiBcImFcIlxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcbiAgcmV0dXJuICEhYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGljb25Mb2FkZWQobmFtZSkge1xuICByZXR1cm4gISFnZXRJY29uRGF0YShuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEljb24obmFtZSkge1xuICBjb25zdCByZXN1bHQgPSBnZXRJY29uRGF0YShuYW1lKTtcbiAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgIC4uLnJlc3VsdFxuICB9IDogcmVzdWx0O1xufVxuXG5jb25zdCBkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsXG59KTtcbmNvbnN0IGRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgLy8gRGltZW5zaW9uc1xuICAuLi5kZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyxcbiAgLy8gVHJhbnNmb3JtYXRpb25zXG4gIC4uLmRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zXG59KTtcblxuY29uc3QgdW5pdHNTcGxpdCA9IC8oLT9bMC05Ll0qWzAtOV0rWzAtOS5dKikvZztcbmNvbnN0IHVuaXRzVGVzdCA9IC9eLT9bMC05Ll0qWzAtOV0rWzAtOS5dKiQvZztcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpemUoc2l6ZSwgcmF0aW8sIHByZWNpc2lvbikge1xuICBpZiAocmF0aW8gPT09IDEpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMTAwO1xuICBpZiAodHlwZW9mIHNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgKiByYXRpbyAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgY29uc3Qgb2xkUGFydHMgPSBzaXplLnNwbGl0KHVuaXRzU3BsaXQpO1xuICBpZiAob2xkUGFydHMgPT09IG51bGwgfHwgIW9sZFBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGNvbnN0IG5ld1BhcnRzID0gW107XG4gIGxldCBjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcbiAgbGV0IGlzTnVtYmVyID0gdW5pdHNUZXN0LnRlc3QoY29kZSk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGlzTnVtYmVyKSB7XG4gICAgICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KGNvZGUpO1xuICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgbmV3UGFydHMucHVzaChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1BhcnRzLnB1c2goTWF0aC5jZWlsKG51bSAqIHJhdGlvICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BhcnRzLnB1c2goY29kZSk7XG4gICAgfVxuICAgIGNvZGUgPSBvbGRQYXJ0cy5zaGlmdCgpO1xuICAgIGlmIChjb2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBuZXdQYXJ0cy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBpc051bWJlciA9ICFpc051bWJlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdFNWR0RlZnMoY29udGVudCwgdGFnID0gXCJkZWZzXCIpIHtcbiAgbGV0IGRlZnMgPSBcIlwiO1xuICBjb25zdCBpbmRleCA9IGNvbnRlbnQuaW5kZXhPZihcIjxcIiArIHRhZyk7XG4gIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBjb250ZW50LmluZGV4T2YoXCI+XCIsIGluZGV4KTtcbiAgICBjb25zdCBlbmQgPSBjb250ZW50LmluZGV4T2YoXCI8L1wiICsgdGFnKTtcbiAgICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBlbmRFbmQgPSBjb250ZW50LmluZGV4T2YoXCI+XCIsIGVuZCk7XG4gICAgaWYgKGVuZEVuZCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZzICs9IGNvbnRlbnQuc2xpY2Uoc3RhcnQgKyAxLCBlbmQpLnRyaW0oKTtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgwLCBpbmRleCkudHJpbSgpICsgY29udGVudC5zbGljZShlbmRFbmQgKyAxKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlZnMsXG4gICAgY29udGVudFxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VEZWZzQW5kQ29udGVudChkZWZzLCBjb250ZW50KSB7XG4gIHJldHVybiBkZWZzID8gXCI8ZGVmcz5cIiArIGRlZnMgKyBcIjwvZGVmcz5cIiArIGNvbnRlbnQgOiBjb250ZW50O1xufVxuZnVuY3Rpb24gd3JhcFNWR0NvbnRlbnQoYm9keSwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBzcGxpdCA9IHNwbGl0U1ZHRGVmcyhib2R5KTtcbiAgcmV0dXJuIG1lcmdlRGVmc0FuZENvbnRlbnQoc3BsaXQuZGVmcywgc3RhcnQgKyBzcGxpdC5jb250ZW50ICsgZW5kKTtcbn1cblxuY29uc3QgaXNVbnNldEtleXdvcmQgPSAodmFsdWUpID0+IHZhbHVlID09PSBcInVuc2V0XCIgfHwgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiO1xuZnVuY3Rpb24gaWNvblRvU1ZHKGljb24sIGN1c3RvbWlzYXRpb25zKSB7XG4gIGNvbnN0IGZ1bGxJY29uID0ge1xuICAgIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gICAgLi4uaWNvblxuICB9O1xuICBjb25zdCBmdWxsQ3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICAuLi5jdXN0b21pc2F0aW9uc1xuICB9O1xuICBjb25zdCBib3ggPSB7XG4gICAgbGVmdDogZnVsbEljb24ubGVmdCxcbiAgICB0b3A6IGZ1bGxJY29uLnRvcCxcbiAgICB3aWR0aDogZnVsbEljb24ud2lkdGgsXG4gICAgaGVpZ2h0OiBmdWxsSWNvbi5oZWlnaHRcbiAgfTtcbiAgbGV0IGJvZHkgPSBmdWxsSWNvbi5ib2R5O1xuICBbZnVsbEljb24sIGZ1bGxDdXN0b21pc2F0aW9uc10uZm9yRWFjaCgocHJvcHMpID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBoRmxpcCA9IHByb3BzLmhGbGlwO1xuICAgIGNvbnN0IHZGbGlwID0gcHJvcHMudkZsaXA7XG4gICAgbGV0IHJvdGF0aW9uID0gcHJvcHMucm90YXRlO1xuICAgIGlmIChoRmxpcCkge1xuICAgICAgaWYgKHZGbGlwKSB7XG4gICAgICAgIHJvdGF0aW9uICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgICBcInRyYW5zbGF0ZShcIiArIChib3gud2lkdGggKyBib3gubGVmdCkudG9TdHJpbmcoKSArIFwiIFwiICsgKDAgLSBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goXCJzY2FsZSgtMSAxKVwiKTtcbiAgICAgICAgYm94LnRvcCA9IGJveC5sZWZ0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZGbGlwKSB7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyAoMCAtIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCArIGJveC50b3ApLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwic2NhbGUoMSAtMSlcIik7XG4gICAgICBib3gudG9wID0gYm94LmxlZnQgPSAwO1xuICAgIH1cbiAgICBsZXQgdGVtcFZhbHVlO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uIC09IE1hdGguZmxvb3Iocm90YXRpb24gLyA0KSAqIDQ7XG4gICAgfVxuICAgIHJvdGF0aW9uID0gcm90YXRpb24gJSA0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGVtcFZhbHVlID0gYm94LmhlaWdodCAvIDIgKyBib3gudG9wO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSg5MCBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIgXCIgKyB0ZW1wVmFsdWUudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSgxODAgXCIgKyAoYm94LndpZHRoIC8gMiArIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCAvIDIgKyBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC53aWR0aCAvIDIgKyBib3gubGVmdDtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXG4gICAgICAgICAgXCJyb3RhdGUoLTkwIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChyb3RhdGlvbiAlIDIgPT09IDEpIHtcbiAgICAgIGlmIChib3gubGVmdCAhPT0gYm94LnRvcCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gubGVmdDtcbiAgICAgICAgYm94LmxlZnQgPSBib3gudG9wO1xuICAgICAgICBib3gudG9wID0gdGVtcFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGJveC53aWR0aCAhPT0gYm94LmhlaWdodCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gud2lkdGg7XG4gICAgICAgIGJveC53aWR0aCA9IGJveC5oZWlnaHQ7XG4gICAgICAgIGJveC5oZWlnaHQgPSB0ZW1wVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBib2R5ID0gd3JhcFNWR0NvbnRlbnQoXG4gICAgICAgIGJvZHksXG4gICAgICAgICc8ZyB0cmFuc2Zvcm09XCInICsgdHJhbnNmb3JtYXRpb25zLmpvaW4oXCIgXCIpICsgJ1wiPicsXG4gICAgICAgIFwiPC9nPlwiXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGN1c3RvbWlzYXRpb25zV2lkdGggPSBmdWxsQ3VzdG9taXNhdGlvbnMud2lkdGg7XG4gIGNvbnN0IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID0gZnVsbEN1c3RvbWlzYXRpb25zLmhlaWdodDtcbiAgY29uc3QgYm94V2lkdGggPSBib3gud2lkdGg7XG4gIGNvbnN0IGJveEhlaWdodCA9IGJveC5oZWlnaHQ7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcbiAgaWYgKGN1c3RvbWlzYXRpb25zV2lkdGggPT09IG51bGwpIHtcbiAgICBoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IFwiMWVtXCIgOiBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gXCJhdXRvXCIgPyBib3hIZWlnaHQgOiBjdXN0b21pc2F0aW9uc0hlaWdodDtcbiAgICB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoaGVpZ2h0LCBib3hXaWR0aCAvIGJveEhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSBjdXN0b21pc2F0aW9uc1dpZHRoID09PSBcImF1dG9cIiA/IGJveFdpZHRoIDogY3VzdG9taXNhdGlvbnNXaWR0aDtcbiAgICBoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IGNhbGN1bGF0ZVNpemUod2lkdGgsIGJveEhlaWdodCAvIGJveFdpZHRoKSA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID09PSBcImF1dG9cIiA/IGJveEhlaWdodCA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0O1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3Qgc2V0QXR0ciA9IChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNVbnNldEtleXdvcmQodmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVzW3Byb3BdID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG4gIHNldEF0dHIoXCJ3aWR0aFwiLCB3aWR0aCk7XG4gIHNldEF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgY29uc3Qgdmlld0JveCA9IFtib3gubGVmdCwgYm94LnRvcCwgYm94V2lkdGgsIGJveEhlaWdodF07XG4gIGF0dHJpYnV0ZXMudmlld0JveCA9IHZpZXdCb3guam9pbihcIiBcIik7XG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlcyxcbiAgICB2aWV3Qm94LFxuICAgIGJvZHlcbiAgfTtcbn1cblxuY29uc3QgcmVnZXggPSAvXFxzaWQ9XCIoXFxTKylcIi9nO1xuY29uc3QgcmFuZG9tUHJlZml4ID0gXCJJY29uaWZ5SWRcIiArIERhdGUubm93KCkudG9TdHJpbmcoMTYpICsgKE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNiB8IDApLnRvU3RyaW5nKDE2KTtcbmxldCBjb3VudGVyID0gMDtcbmZ1bmN0aW9uIHJlcGxhY2VJRHMoYm9keSwgcHJlZml4ID0gcmFuZG9tUHJlZml4KSB7XG4gIGNvbnN0IGlkcyA9IFtdO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlZ2V4LmV4ZWMoYm9keSkpIHtcbiAgICBpZHMucHVzaChtYXRjaFsxXSk7XG4gIH1cbiAgaWYgKCFpZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgY29uc3Qgc3VmZml4ID0gXCJzdWZmaXhcIiArIChNYXRoLnJhbmRvbSgpICogMTY3NzcyMTYgfCBEYXRlLm5vdygpKS50b1N0cmluZygxNik7XG4gIGlkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgIGNvbnN0IG5ld0lEID0gdHlwZW9mIHByZWZpeCA9PT0gXCJmdW5jdGlvblwiID8gcHJlZml4KGlkKSA6IHByZWZpeCArIChjb3VudGVyKyspLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgZXNjYXBlZElEID0gaWQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoXG4gICAgICAvLyBBbGxvd2VkIGNoYXJhY3RlcnMgYmVmb3JlIGlkOiBbIztcIl1cbiAgICAgIC8vIEFsbG93ZWQgY2hhcmFjdGVycyBhZnRlciBpZDogWylcIl0sIC5bYS16XVxuICAgICAgbmV3IFJlZ0V4cCgnKFsjO1wiXSkoJyArIGVzY2FwZWRJRCArICcpKFtcIildfFxcXFwuW2Etel0pJywgXCJnXCIpLFxuICAgICAgXCIkMVwiICsgbmV3SUQgKyBzdWZmaXggKyBcIiQzXCJcbiAgICApO1xuICB9KTtcbiAgYm9keSA9IGJvZHkucmVwbGFjZShuZXcgUmVnRXhwKHN1ZmZpeCwgXCJnXCIpLCBcIlwiKTtcbiAgcmV0dXJuIGJvZHk7XG59XG5cbmNvbnN0IHN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIHNldEFQSU1vZHVsZShwcm92aWRlciwgaXRlbSkge1xuICBzdG9yYWdlW3Byb3ZpZGVyXSA9IGl0ZW07XG59XG5mdW5jdGlvbiBnZXRBUElNb2R1bGUocHJvdmlkZXIpIHtcbiAgcmV0dXJuIHN0b3JhZ2VbcHJvdmlkZXJdIHx8IHN0b3JhZ2VbXCJcIl07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFQSUNvbmZpZyhzb3VyY2UpIHtcbiAgbGV0IHJlc291cmNlcztcbiAgaWYgKHR5cGVvZiBzb3VyY2UucmVzb3VyY2VzID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmVzb3VyY2VzID0gW3NvdXJjZS5yZXNvdXJjZXNdO1xuICB9IGVsc2Uge1xuICAgIHJlc291cmNlcyA9IHNvdXJjZS5yZXNvdXJjZXM7XG4gICAgaWYgKCEocmVzb3VyY2VzIGluc3RhbmNlb2YgQXJyYXkpIHx8ICFyZXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC8vIEFQSSBob3N0c1xuICAgIHJlc291cmNlcyxcbiAgICAvLyBSb290IHBhdGhcbiAgICBwYXRoOiBzb3VyY2UucGF0aCB8fCBcIi9cIixcbiAgICAvLyBVUkwgbGVuZ3RoIGxpbWl0XG4gICAgbWF4VVJMOiBzb3VyY2UubWF4VVJMIHx8IDUwMCxcbiAgICAvLyBUaW1lb3V0IGJlZm9yZSBuZXh0IGhvc3QgaXMgdXNlZC5cbiAgICByb3RhdGU6IHNvdXJjZS5yb3RhdGUgfHwgNzUwLFxuICAgIC8vIFRpbWVvdXQgYmVmb3JlIGZhaWxpbmcgcXVlcnkuXG4gICAgdGltZW91dDogc291cmNlLnRpbWVvdXQgfHwgNWUzLFxuICAgIC8vIFJhbmRvbWlzZSBkZWZhdWx0IEFQSSBlbmQgcG9pbnQuXG4gICAgcmFuZG9tOiBzb3VyY2UucmFuZG9tID09PSB0cnVlLFxuICAgIC8vIFN0YXJ0IGluZGV4XG4gICAgaW5kZXg6IHNvdXJjZS5pbmRleCB8fCAwLFxuICAgIC8vIFJlY2VpdmUgZGF0YSBhZnRlciB0aW1lIG91dCAodXNlZCBpZiB0aW1lIG91dCBraWNrcyBpbiBmaXJzdCwgdGhlbiBBUEkgbW9kdWxlIHNlbmRzIGRhdGEgYW55d2F5KS5cbiAgICBkYXRhQWZ0ZXJUaW1lb3V0OiBzb3VyY2UuZGF0YUFmdGVyVGltZW91dCAhPT0gZmFsc2VcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGNvbmZpZ1N0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGZhbGxCYWNrQVBJU291cmNlcyA9IFtcbiAgXCJodHRwczovL2FwaS5zaW1wbGVzdmcuY29tXCIsXG4gIFwiaHR0cHM6Ly9hcGkudW5pc3ZnLmNvbVwiXG5dO1xuY29uc3QgZmFsbEJhY2tBUEkgPSBbXTtcbndoaWxlIChmYWxsQmFja0FQSVNvdXJjZXMubGVuZ3RoID4gMCkge1xuICBpZiAoZmFsbEJhY2tBUElTb3VyY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnNoaWZ0KCkpO1xuICB9IGVsc2Uge1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5zaGlmdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMucG9wKCkpO1xuICAgIH1cbiAgfVxufVxuY29uZmlnU3RvcmFnZVtcIlwiXSA9IGNyZWF0ZUFQSUNvbmZpZyh7XG4gIHJlc291cmNlczogW1wiaHR0cHM6Ly9hcGkuaWNvbmlmeS5kZXNpZ25cIl0uY29uY2F0KGZhbGxCYWNrQVBJKVxufSk7XG5mdW5jdGlvbiBhZGRBUElQcm92aWRlcihwcm92aWRlciwgY3VzdG9tQ29uZmlnKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUFQSUNvbmZpZyhjdXN0b21Db25maWcpO1xuICBpZiAoY29uZmlnID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbmZpZ1N0b3JhZ2VbcHJvdmlkZXJdID0gY29uZmlnO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEFQSUNvbmZpZyhwcm92aWRlcikge1xuICByZXR1cm4gY29uZmlnU3RvcmFnZVtwcm92aWRlcl07XG59XG5mdW5jdGlvbiBsaXN0QVBJUHJvdmlkZXJzKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoY29uZmlnU3RvcmFnZSk7XG59XG5cbmNvbnN0IGRldGVjdEZldGNoID0gKCkgPT4ge1xuICBsZXQgY2FsbGJhY2s7XG4gIHRyeSB7XG4gICAgY2FsbGJhY2sgPSBmZXRjaDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG59O1xubGV0IGZldGNoTW9kdWxlID0gZGV0ZWN0RmV0Y2goKTtcbmZ1bmN0aW9uIHNldEZldGNoKGZldGNoMikge1xuICBmZXRjaE1vZHVsZSA9IGZldGNoMjtcbn1cbmZ1bmN0aW9uIGdldEZldGNoKCkge1xuICByZXR1cm4gZmV0Y2hNb2R1bGU7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVNYXhMZW5ndGgocHJvdmlkZXIsIHByZWZpeCkge1xuICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIGlmICghY29uZmlnLm1heFVSTCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGV0IG1heEhvc3RMZW5ndGggPSAwO1xuICAgIGNvbmZpZy5yZXNvdXJjZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgaG9zdCA9IGl0ZW07XG4gICAgICBtYXhIb3N0TGVuZ3RoID0gTWF0aC5tYXgobWF4SG9zdExlbmd0aCwgaG9zdC5sZW5ndGgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHVybCA9IHByZWZpeCArIFwiLmpzb24/aWNvbnM9XCI7XG4gICAgcmVzdWx0ID0gY29uZmlnLm1heFVSTCAtIG1heEhvc3RMZW5ndGggLSBjb25maWcucGF0aC5sZW5ndGggLSB1cmwubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzaG91bGRBYm9ydChzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gNDA0O1xufVxuY29uc3QgcHJlcGFyZSA9IChwcm92aWRlciwgcHJlZml4LCBpY29ucykgPT4ge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGNvbnN0IG1heExlbmd0aCA9IGNhbGN1bGF0ZU1heExlbmd0aChwcm92aWRlciwgcHJlZml4KTtcbiAgY29uc3QgdHlwZSA9IFwiaWNvbnNcIjtcbiAgbGV0IGl0ZW0gPSB7XG4gICAgdHlwZSxcbiAgICBwcm92aWRlcixcbiAgICBwcmVmaXgsXG4gICAgaWNvbnM6IFtdXG4gIH07XG4gIGxldCBsZW5ndGggPSAwO1xuICBpY29ucy5mb3JFYWNoKChuYW1lLCBpbmRleCkgPT4ge1xuICAgIGxlbmd0aCArPSBuYW1lLmxlbmd0aCArIDE7XG4gICAgaWYgKGxlbmd0aCA+PSBtYXhMZW5ndGggJiYgaW5kZXggPiAwKSB7XG4gICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgcHJlZml4LFxuICAgICAgICBpY29uczogW11cbiAgICAgIH07XG4gICAgICBsZW5ndGggPSBuYW1lLmxlbmd0aDtcbiAgICB9XG4gICAgaXRlbS5pY29ucy5wdXNoKG5hbWUpO1xuICB9KTtcbiAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5mdW5jdGlvbiBnZXRQYXRoKHByb3ZpZGVyKSB7XG4gIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHJldHVybiBjb25maWcucGF0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiL1wiO1xufVxuY29uc3Qgc2VuZCA9IChob3N0LCBwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICghZmV0Y2hNb2R1bGUpIHtcbiAgICBjYWxsYmFjayhcImFib3J0XCIsIDQyNCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBwYXRoID0gZ2V0UGF0aChwYXJhbXMucHJvdmlkZXIpO1xuICBzd2l0Y2ggKHBhcmFtcy50eXBlKSB7XG4gICAgY2FzZSBcImljb25zXCI6IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHBhcmFtcy5wcmVmaXg7XG4gICAgICBjb25zdCBpY29ucyA9IHBhcmFtcy5pY29ucztcbiAgICAgIGNvbnN0IGljb25zTGlzdCA9IGljb25zLmpvaW4oXCIsXCIpO1xuICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGljb25zOiBpY29uc0xpc3RcbiAgICAgIH0pO1xuICAgICAgcGF0aCArPSBwcmVmaXggKyBcIi5qc29uP1wiICsgdXJsUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImN1c3RvbVwiOiB7XG4gICAgICBjb25zdCB1cmkgPSBwYXJhbXMudXJpO1xuICAgICAgcGF0aCArPSB1cmkuc2xpY2UoMCwgMSkgPT09IFwiL1wiID8gdXJpLnNsaWNlKDEpIDogdXJpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBjYWxsYmFjayhcImFib3J0XCIsIDQwMCk7XG4gICAgICByZXR1cm47XG4gIH1cbiAgbGV0IGRlZmF1bHRFcnJvciA9IDUwMztcbiAgZmV0Y2hNb2R1bGUoaG9zdCArIHBhdGgpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGlmIChzdGF0dXMgIT09IDIwMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHNob3VsZEFib3J0KHN0YXR1cykgPyBcImFib3J0XCIgOiBcIm5leHRcIiwgc3RhdHVzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWZhdWx0RXJyb3IgPSA1MDE7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGRhdGEgPT09IDQwNCkge1xuICAgICAgICAgIGNhbGxiYWNrKFwiYWJvcnRcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soXCJuZXh0XCIsIGRlZmF1bHRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKFwic3VjY2Vzc1wiLCBkYXRhKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goKCkgPT4ge1xuICAgIGNhbGxiYWNrKFwibmV4dFwiLCBkZWZhdWx0RXJyb3IpO1xuICB9KTtcbn07XG5jb25zdCBmZXRjaEFQSU1vZHVsZSA9IHtcbiAgcHJlcGFyZSxcbiAgc2VuZFxufTtcblxuZnVuY3Rpb24gc29ydEljb25zKGljb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBsb2FkZWQ6IFtdLFxuICAgIG1pc3Npbmc6IFtdLFxuICAgIHBlbmRpbmc6IFtdXG4gIH07XG4gIGNvbnN0IHN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWNvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLnByb3ZpZGVyICE9PSBiLnByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gYS5wcm92aWRlci5sb2NhbGVDb21wYXJlKGIucHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoYS5wcmVmaXggIT09IGIucHJlZml4KSB7XG4gICAgICByZXR1cm4gYS5wcmVmaXgubG9jYWxlQ29tcGFyZShiLnByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICB9KTtcbiAgbGV0IGxhc3RJY29uID0ge1xuICAgIHByb3ZpZGVyOiBcIlwiLFxuICAgIHByZWZpeDogXCJcIixcbiAgICBuYW1lOiBcIlwiXG4gIH07XG4gIGljb25zLmZvckVhY2goKGljb24pID0+IHtcbiAgICBpZiAobGFzdEljb24ubmFtZSA9PT0gaWNvbi5uYW1lICYmIGxhc3RJY29uLnByZWZpeCA9PT0gaWNvbi5wcmVmaXggJiYgbGFzdEljb24ucHJvdmlkZXIgPT09IGljb24ucHJvdmlkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdEljb24gPSBpY29uO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gaWNvbi5wcm92aWRlcjtcbiAgICBjb25zdCBwcmVmaXggPSBpY29uLnByZWZpeDtcbiAgICBjb25zdCBuYW1lID0gaWNvbi5uYW1lO1xuICAgIGNvbnN0IHByb3ZpZGVyU3RvcmFnZSA9IHN0b3JhZ2VbcHJvdmlkZXJdIHx8IChzdG9yYWdlW3Byb3ZpZGVyXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBjb25zdCBsb2NhbFN0b3JhZ2UgPSBwcm92aWRlclN0b3JhZ2VbcHJlZml4XSB8fCAocHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpKTtcbiAgICBsZXQgbGlzdDtcbiAgICBpZiAobmFtZSBpbiBsb2NhbFN0b3JhZ2UuaWNvbnMpIHtcbiAgICAgIGxpc3QgPSByZXN1bHQubG9hZGVkO1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSBcIlwiIHx8IGxvY2FsU3RvcmFnZS5taXNzaW5nLmhhcyhuYW1lKSkge1xuICAgICAgbGlzdCA9IHJlc3VsdC5taXNzaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ID0gcmVzdWx0LnBlbmRpbmc7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeCxcbiAgICAgIG5hbWVcbiAgICB9O1xuICAgIGxpc3QucHVzaChpdGVtKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrKHN0b3JhZ2VzLCBpZCkge1xuICBzdG9yYWdlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcztcbiAgICBpZiAoaXRlbXMpIHtcbiAgICAgIHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzID0gaXRlbXMuZmlsdGVyKChyb3cpID0+IHJvdy5pZCAhPT0gaWQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFja3Moc3RvcmFnZSkge1xuICBpZiAoIXN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcpIHtcbiAgICBzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3MgPyBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcy5zbGljZSgwKSA6IFtdO1xuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGhhc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gc3RvcmFnZS5wcm92aWRlcjtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHN0b3JhZ2UucHJlZml4O1xuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpY29ucyA9IGl0ZW0uaWNvbnM7XG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IGljb25zLnBlbmRpbmcubGVuZ3RoO1xuICAgICAgICBpY29ucy5wZW5kaW5nID0gaWNvbnMucGVuZGluZy5maWx0ZXIoKGljb24pID0+IHtcbiAgICAgICAgICBpZiAoaWNvbi5wcmVmaXggIT09IHByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5hbWUgPSBpY29uLm5hbWU7XG4gICAgICAgICAgaWYgKHN0b3JhZ2UuaWNvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGljb25zLmxvYWRlZC5wdXNoKHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yYWdlLm1pc3NpbmcuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpY29ucy5taXNzaW5nLnB1c2goe1xuICAgICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGljb25zLnBlbmRpbmcubGVuZ3RoICE9PSBvbGRMZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWhhc1BlbmRpbmcpIHtcbiAgICAgICAgICAgIHJlbW92ZUNhbGxiYWNrKFtzdG9yYWdlXSwgaXRlbS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0uY2FsbGJhY2soXG4gICAgICAgICAgICBpY29ucy5sb2FkZWQuc2xpY2UoMCksXG4gICAgICAgICAgICBpY29ucy5taXNzaW5nLnNsaWNlKDApLFxuICAgICAgICAgICAgaWNvbnMucGVuZGluZy5zbGljZSgwKSxcbiAgICAgICAgICAgIGl0ZW0uYWJvcnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxubGV0IGlkQ291bnRlciA9IDA7XG5mdW5jdGlvbiBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBpY29ucywgcGVuZGluZ1NvdXJjZXMpIHtcbiAgY29uc3QgaWQgPSBpZENvdW50ZXIrKztcbiAgY29uc3QgYWJvcnQgPSByZW1vdmVDYWxsYmFjay5iaW5kKG51bGwsIHBlbmRpbmdTb3VyY2VzLCBpZCk7XG4gIGlmICghaWNvbnMucGVuZGluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWJvcnQ7XG4gIH1cbiAgY29uc3QgaXRlbSA9IHtcbiAgICBpZCxcbiAgICBpY29ucyxcbiAgICBjYWxsYmFjayxcbiAgICBhYm9ydFxuICB9O1xuICBwZW5kaW5nU291cmNlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgKHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzIHx8IChzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA9IFtdKSkucHVzaChpdGVtKTtcbiAgfSk7XG4gIHJldHVybiBhYm9ydDtcbn1cblxuZnVuY3Rpb24gbGlzdFRvSWNvbnMobGlzdCwgdmFsaWRhdGUgPSB0cnVlLCBzaW1wbGVOYW1lcyA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBjb25zdCBpY29uID0gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaXRlbSwgdmFsaWRhdGUsIHNpbXBsZU5hbWVzKSA6IGl0ZW07XG4gICAgaWYgKGljb24pIHtcbiAgICAgIHJlc3VsdC5wdXNoKGljb24pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9jb25maWcudHNcbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICByZXNvdXJjZXM6IFtdLFxuICBpbmRleDogMCxcbiAgdGltZW91dDogMmUzLFxuICByb3RhdGU6IDc1MCxcbiAgcmFuZG9tOiBmYWxzZSxcbiAgZGF0YUFmdGVyVGltZW91dDogZmFsc2Vcbn07XG5cbi8vIHNyYy9xdWVyeS50c1xuZnVuY3Rpb24gc2VuZFF1ZXJ5KGNvbmZpZywgcGF5bG9hZCwgcXVlcnksIGRvbmUpIHtcbiAgY29uc3QgcmVzb3VyY2VzQ291bnQgPSBjb25maWcucmVzb3VyY2VzLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGNvbmZpZy5yYW5kb20gPyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZXNvdXJjZXNDb3VudCkgOiBjb25maWcuaW5kZXg7XG4gIGxldCByZXNvdXJjZXM7XG4gIGlmIChjb25maWcucmFuZG9tKSB7XG4gICAgbGV0IGxpc3QgPSBjb25maWcucmVzb3VyY2VzLnNsaWNlKDApO1xuICAgIHJlc291cmNlcyA9IFtdO1xuICAgIHdoaWxlIChsaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG5leHRJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxpc3QubGVuZ3RoKTtcbiAgICAgIHJlc291cmNlcy5wdXNoKGxpc3RbbmV4dEluZGV4XSk7XG4gICAgICBsaXN0ID0gbGlzdC5zbGljZSgwLCBuZXh0SW5kZXgpLmNvbmNhdChsaXN0LnNsaWNlKG5leHRJbmRleCArIDEpKTtcbiAgICB9XG4gICAgcmVzb3VyY2VzID0gcmVzb3VyY2VzLmNvbmNhdChsaXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXNvdXJjZXMgPSBjb25maWcucmVzb3VyY2VzLnNsaWNlKHN0YXJ0SW5kZXgpLmNvbmNhdChjb25maWcucmVzb3VyY2VzLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcbiAgfVxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBsZXQgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gIGxldCBxdWVyaWVzU2VudCA9IDA7XG4gIGxldCBsYXN0RXJyb3I7XG4gIGxldCB0aW1lciA9IG51bGw7XG4gIGxldCBxdWV1ZSA9IFtdO1xuICBsZXQgZG9uZUNhbGxiYWNrcyA9IFtdO1xuICBpZiAodHlwZW9mIGRvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRvbmVDYWxsYmFja3MucHVzaChkb25lKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldFRpbWVyKCkge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICByZXNldFRpbWVyKCk7XG4gICAgcXVldWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICBpdGVtLnN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHF1ZXVlID0gW107XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrLCBvdmVyd3JpdGUpIHtcbiAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICBkb25lQ2FsbGJhY2tzID0gW107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZG9uZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UXVlcnlTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIHBheWxvYWQsXG4gICAgICBzdGF0dXMsXG4gICAgICBxdWVyaWVzU2VudCxcbiAgICAgIHF1ZXJpZXNQZW5kaW5nOiBxdWV1ZS5sZW5ndGgsXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBhYm9ydFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmFpbFF1ZXJ5KCkge1xuICAgIHN0YXR1cyA9IFwiZmFpbGVkXCI7XG4gICAgZG9uZUNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2sodm9pZCAwLCBsYXN0RXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gICAgcXVldWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICBpdGVtLnN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHF1ZXVlID0gW107XG4gIH1cbiAgZnVuY3Rpb24gbW9kdWxlUmVzcG9uc2UoaXRlbSwgcmVzcG9uc2UsIGRhdGEpIHtcbiAgICBjb25zdCBpc0Vycm9yID0gcmVzcG9uc2UgIT09IFwic3VjY2Vzc1wiO1xuICAgIHF1ZXVlID0gcXVldWUuZmlsdGVyKChxdWV1ZWQpID0+IHF1ZXVlZCAhPT0gaXRlbSk7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICBpZiAoaXNFcnJvciB8fCAhY29uZmlnLmRhdGFBZnRlclRpbWVvdXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwb25zZSA9PT0gXCJhYm9ydFwiKSB7XG4gICAgICBsYXN0RXJyb3IgPSBkYXRhO1xuICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICBsYXN0RXJyb3IgPSBkYXRhO1xuICAgICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFyZXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY05leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNldFRpbWVyKCk7XG4gICAgY2xlYXJRdWV1ZSgpO1xuICAgIGlmICghY29uZmlnLnJhbmRvbSkge1xuICAgICAgY29uc3QgaW5kZXggPSBjb25maWcucmVzb3VyY2VzLmluZGV4T2YoaXRlbS5yZXNvdXJjZSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4ICE9PSBjb25maWcuaW5kZXgpIHtcbiAgICAgICAgY29uZmlnLmluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXR1cyA9IFwiY29tcGxldGVkXCI7XG4gICAgZG9uZUNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZXhlY05leHQoKSB7XG4gICAgaWYgKHN0YXR1cyAhPT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKHJlc291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXNldFRpbWVyKCk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmYWlsUXVlcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHtcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICByZXNvdXJjZSxcbiAgICAgIGNhbGxiYWNrOiAoc3RhdHVzMiwgZGF0YSkgPT4ge1xuICAgICAgICBtb2R1bGVSZXNwb25zZShpdGVtLCBzdGF0dXMyLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgcXVlcmllc1NlbnQrKztcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZXhlY05leHQsIGNvbmZpZy5yb3RhdGUpO1xuICAgIHF1ZXJ5KHJlc291cmNlLCBwYXlsb2FkLCBpdGVtLmNhbGxiYWNrKTtcbiAgfVxuICBzZXRUaW1lb3V0KGV4ZWNOZXh0KTtcbiAgcmV0dXJuIGdldFF1ZXJ5U3RhdHVzO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGluaXRSZWR1bmRhbmN5KGNmZykge1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAuLi5jZmdcbiAgfTtcbiAgbGV0IHF1ZXJpZXMgPSBbXTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBxdWVyaWVzID0gcXVlcmllcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0oKS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKTtcbiAgfVxuICBmdW5jdGlvbiBxdWVyeShwYXlsb2FkLCBxdWVyeUNhbGxiYWNrLCBkb25lQ2FsbGJhY2spIHtcbiAgICBjb25zdCBxdWVyeTIgPSBzZW5kUXVlcnkoXG4gICAgICBjb25maWcsXG4gICAgICBwYXlsb2FkLFxuICAgICAgcXVlcnlDYWxsYmFjayxcbiAgICAgIChkYXRhLCBlcnJvcikgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGlmIChkb25lQ2FsbGJhY2spIHtcbiAgICAgICAgICBkb25lQ2FsbGJhY2soZGF0YSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBxdWVyaWVzLnB1c2gocXVlcnkyKTtcbiAgICByZXR1cm4gcXVlcnkyO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcXVlcmllcy5maW5kKCh2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlKTtcbiAgICB9KSB8fCBudWxsO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHF1ZXJ5LFxuICAgIGZpbmQsXG4gICAgc2V0SW5kZXg6IChpbmRleCkgPT4ge1xuICAgICAgY29uZmlnLmluZGV4ID0gaW5kZXg7XG4gICAgfSxcbiAgICBnZXRJbmRleDogKCkgPT4gY29uZmlnLmluZGV4LFxuICAgIGNsZWFudXBcbiAgfTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrJDEoKSB7XG59XG5jb25zdCByZWR1bmRhbmN5Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFJlZHVuZGFuY3lDYWNoZShwcm92aWRlcikge1xuICBpZiAoIXJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0pIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlZHVuZGFuY3kgPSBpbml0UmVkdW5kYW5jeShjb25maWcpO1xuICAgIGNvbnN0IGNhY2hlZFJldW5kYW5jeSA9IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlZHVuZGFuY3lcbiAgICB9O1xuICAgIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0gPSBjYWNoZWRSZXVuZGFuY3k7XG4gIH1cbiAgcmV0dXJuIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl07XG59XG5mdW5jdGlvbiBzZW5kQVBJUXVlcnkodGFyZ2V0LCBxdWVyeSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlZHVuZGFuY3k7XG4gIGxldCBzZW5kO1xuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZSh0YXJnZXQpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICBjYWxsYmFjayh2b2lkIDAsIDQyNCk7XG4gICAgICByZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuICAgIH1cbiAgICBzZW5kID0gYXBpLnNlbmQ7XG4gICAgY29uc3QgY2FjaGVkID0gZ2V0UmVkdW5kYW5jeUNhY2hlKHRhcmdldCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmVkdW5kYW5jeSA9IGNhY2hlZC5yZWR1bmRhbmN5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb25maWcgPSBjcmVhdGVBUElDb25maWcodGFyZ2V0KTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICByZWR1bmRhbmN5ID0gaW5pdFJlZHVuZGFuY3koY29uZmlnKTtcbiAgICAgIGNvbnN0IG1vZHVsZUtleSA9IHRhcmdldC5yZXNvdXJjZXMgPyB0YXJnZXQucmVzb3VyY2VzWzBdIDogXCJcIjtcbiAgICAgIGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZShtb2R1bGVLZXkpO1xuICAgICAgaWYgKGFwaSkge1xuICAgICAgICBzZW5kID0gYXBpLnNlbmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghcmVkdW5kYW5jeSB8fCAhc2VuZCkge1xuICAgIGNhbGxiYWNrKHZvaWQgMCwgNDI0KTtcbiAgICByZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuICB9XG4gIHJldHVybiByZWR1bmRhbmN5LnF1ZXJ5KHF1ZXJ5LCBzZW5kLCBjYWxsYmFjaykoKS5hYm9ydDtcbn1cblxuZnVuY3Rpb24gZW1wdHlDYWxsYmFjaygpIHtcbn1cbmZ1bmN0aW9uIGxvYWRlZE5ld0ljb25zKHN0b3JhZ2UpIHtcbiAgaWYgKCFzdG9yYWdlLmljb25zTG9hZGVyRmxhZykge1xuICAgIHN0b3JhZ2UuaWNvbnNMb2FkZXJGbGFnID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0b3JhZ2UuaWNvbnNMb2FkZXJGbGFnID0gZmFsc2U7XG4gICAgICB1cGRhdGVDYWxsYmFja3Moc3RvcmFnZSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSWNvbk5hbWVzRm9yQVBJKGljb25zKSB7XG4gIGNvbnN0IHZhbGlkID0gW107XG4gIGNvbnN0IGludmFsaWQgPSBbXTtcbiAgaWNvbnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIChuYW1lLm1hdGNoKG1hdGNoSWNvbk5hbWUpID8gdmFsaWQgOiBpbnZhbGlkKS5wdXNoKG5hbWUpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB2YWxpZCxcbiAgICBpbnZhbGlkXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGljb25zLCBkYXRhKSB7XG4gIGZ1bmN0aW9uIGNoZWNrTWlzc2luZygpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gc3RvcmFnZS5wZW5kaW5nSWNvbnM7XG4gICAgaWNvbnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgcGVuZGluZy5kZWxldGUobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0b3JhZ2UuaWNvbnNbbmFtZV0pIHtcbiAgICAgICAgc3RvcmFnZS5taXNzaW5nLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEpO1xuICAgICAgaWYgKCFwYXJzZWQubGVuZ3RoKSB7XG4gICAgICAgIGNoZWNrTWlzc2luZygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9XG4gIGNoZWNrTWlzc2luZygpO1xuICBsb2FkZWROZXdJY29ucyhzdG9yYWdlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUG9zc2libHlBc3luY1Jlc3BvbnNlKHJlc3BvbnNlLCBjYWxsYmFjaykge1xuICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgcmVzcG9uc2UudGhlbigoZGF0YSkgPT4ge1xuICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICB9XG59XG5mdW5jdGlvbiBsb2FkTmV3SWNvbnMoc3RvcmFnZSwgaWNvbnMpIHtcbiAgaWYgKCFzdG9yYWdlLmljb25zVG9Mb2FkKSB7XG4gICAgc3RvcmFnZS5pY29uc1RvTG9hZCA9IGljb25zO1xuICB9IGVsc2Uge1xuICAgIHN0b3JhZ2UuaWNvbnNUb0xvYWQgPSBzdG9yYWdlLmljb25zVG9Mb2FkLmNvbmNhdChpY29ucykuc29ydCgpO1xuICB9XG4gIGlmICghc3RvcmFnZS5pY29uc1F1ZXVlRmxhZykge1xuICAgIHN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RvcmFnZS5pY29uc1F1ZXVlRmxhZyA9IGZhbHNlO1xuICAgICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4IH0gPSBzdG9yYWdlO1xuICAgICAgY29uc3QgaWNvbnMyID0gc3RvcmFnZS5pY29uc1RvTG9hZDtcbiAgICAgIGRlbGV0ZSBzdG9yYWdlLmljb25zVG9Mb2FkO1xuICAgICAgaWYgKCFpY29uczIgfHwgIWljb25zMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VzdG9tSWNvbkxvYWRlciA9IHN0b3JhZ2UubG9hZEljb247XG4gICAgICBpZiAoc3RvcmFnZS5sb2FkSWNvbnMgJiYgKGljb25zMi5sZW5ndGggPiAxIHx8ICFjdXN0b21JY29uTG9hZGVyKSkge1xuICAgICAgICBwYXJzZVBvc3NpYmx5QXN5bmNSZXNwb25zZShcbiAgICAgICAgICBzdG9yYWdlLmxvYWRJY29ucyhpY29uczIsIHByZWZpeCwgcHJvdmlkZXIpLFxuICAgICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGljb25zMiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY3VzdG9tSWNvbkxvYWRlcikge1xuICAgICAgICBpY29uczIuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY3VzdG9tSWNvbkxvYWRlcihuYW1lLCBwcmVmaXgsIHByb3ZpZGVyKTtcbiAgICAgICAgICBwYXJzZVBvc3NpYmx5QXN5bmNSZXNwb25zZShyZXNwb25zZSwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGljb25TZXQgPSBkYXRhID8ge1xuICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgIGljb25zOiB7XG4gICAgICAgICAgICAgICAgW25hbWVdOiBkYXRhXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgICAgcGFyc2VMb2FkZXJSZXNwb25zZShzdG9yYWdlLCBbbmFtZV0sIGljb25TZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB2YWxpZCwgaW52YWxpZCB9ID0gY2hlY2tJY29uTmFtZXNGb3JBUEkoaWNvbnMyKTtcbiAgICAgIGlmIChpbnZhbGlkLmxlbmd0aCkge1xuICAgICAgICBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIGludmFsaWQsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWxpZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYXBpID0gcHJlZml4Lm1hdGNoKG1hdGNoSWNvbk5hbWUpID8gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSA6IG51bGw7XG4gICAgICBpZiAoIWFwaSkge1xuICAgICAgICBwYXJzZUxvYWRlclJlc3BvbnNlKHN0b3JhZ2UsIHZhbGlkLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyYW1zID0gYXBpLnByZXBhcmUocHJvdmlkZXIsIHByZWZpeCwgdmFsaWQpO1xuICAgICAgcGFyYW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgc2VuZEFQSVF1ZXJ5KHByb3ZpZGVyLCBpdGVtLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIHBhcnNlTG9hZGVyUmVzcG9uc2Uoc3RvcmFnZSwgaXRlbS5pY29ucywgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGxvYWRJY29ucyA9IChpY29ucywgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgY2xlYW5lZEljb25zID0gbGlzdFRvSWNvbnMoaWNvbnMsIHRydWUsIGFsbG93U2ltcGxlTmFtZXMoKSk7XG4gIGNvbnN0IHNvcnRlZEljb25zID0gc29ydEljb25zKGNsZWFuZWRJY29ucyk7XG4gIGlmICghc29ydGVkSWNvbnMucGVuZGluZy5sZW5ndGgpIHtcbiAgICBsZXQgY2FsbENhbGxiYWNrID0gdHJ1ZTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY2FsbENhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICBzb3J0ZWRJY29ucy5sb2FkZWQsXG4gICAgICAgICAgICBzb3J0ZWRJY29ucy5taXNzaW5nLFxuICAgICAgICAgICAgc29ydGVkSWNvbnMucGVuZGluZyxcbiAgICAgICAgICAgIGVtcHR5Q2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbGxDYWxsYmFjayA9IGZhbHNlO1xuICAgIH07XG4gIH1cbiAgY29uc3QgbmV3SWNvbnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc291cmNlcyA9IFtdO1xuICBsZXQgbGFzdFByb3ZpZGVyLCBsYXN0UHJlZml4O1xuICBzb3J0ZWRJY29ucy5wZW5kaW5nLmZvckVhY2goKGljb24pID0+IHtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXggfSA9IGljb247XG4gICAgaWYgKHByZWZpeCA9PT0gbGFzdFByZWZpeCAmJiBwcm92aWRlciA9PT0gbGFzdFByb3ZpZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIGxhc3RQcmVmaXggPSBwcmVmaXg7XG4gICAgc291cmNlcy5wdXNoKGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkpO1xuICAgIGNvbnN0IHByb3ZpZGVyTmV3SWNvbnMgPSBuZXdJY29uc1twcm92aWRlcl0gfHwgKG5ld0ljb25zW3Byb3ZpZGVyXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBpZiAoIXByb3ZpZGVyTmV3SWNvbnNbcHJlZml4XSkge1xuICAgICAgcHJvdmlkZXJOZXdJY29uc1twcmVmaXhdID0gW107XG4gICAgfVxuICB9KTtcbiAgc29ydGVkSWNvbnMucGVuZGluZy5mb3JFYWNoKChpY29uKSA9PiB7XG4gICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4LCBuYW1lIH0gPSBpY29uO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpO1xuICAgIGNvbnN0IHBlbmRpbmdRdWV1ZSA9IHN0b3JhZ2UucGVuZGluZ0ljb25zIHx8IChzdG9yYWdlLnBlbmRpbmdJY29ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIGlmICghcGVuZGluZ1F1ZXVlLmhhcyhuYW1lKSkge1xuICAgICAgcGVuZGluZ1F1ZXVlLmFkZChuYW1lKTtcbiAgICAgIG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdLnB1c2gobmFtZSk7XG4gICAgfVxuICB9KTtcbiAgc291cmNlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgY29uc3QgbGlzdCA9IG5ld0ljb25zW3N0b3JhZ2UucHJvdmlkZXJdW3N0b3JhZ2UucHJlZml4XTtcbiAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgIGxvYWROZXdJY29ucyhzdG9yYWdlLCBsaXN0KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2sgPyBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBzb3J0ZWRJY29ucywgc291cmNlcykgOiBlbXB0eUNhbGxiYWNrO1xufTtcbmNvbnN0IGxvYWRJY29uID0gKGljb24pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpY29uT2JqID0gdHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaWNvbiwgdHJ1ZSkgOiBpY29uO1xuICAgIGlmICghaWNvbk9iaikge1xuICAgICAgcmVqZWN0KGljb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2FkSWNvbnMoW2ljb25PYmogfHwgaWNvbl0sIChsb2FkZWQpID0+IHtcbiAgICAgIGlmIChsb2FkZWQubGVuZ3RoICYmIGljb25PYmopIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25EYXRhKGljb25PYmopO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGZ1bGZpbGwoe1xuICAgICAgICAgICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAgICAgICAgIC4uLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlamVjdChpY29uKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBzZXRDdXN0b21JY29uc0xvYWRlcihsb2FkZXIsIHByZWZpeCwgcHJvdmlkZXIpIHtcbiAgZ2V0U3RvcmFnZShwcm92aWRlciB8fCBcIlwiLCBwcmVmaXgpLmxvYWRJY29ucyA9IGxvYWRlcjtcbn1cbmZ1bmN0aW9uIHNldEN1c3RvbUljb25Mb2FkZXIobG9hZGVyLCBwcmVmaXgsIHByb3ZpZGVyKSB7XG4gIGdldFN0b3JhZ2UocHJvdmlkZXIgfHwgXCJcIiwgcHJlZml4KS5sb2FkSWNvbiA9IGxvYWRlcjtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDdXN0b21pc2F0aW9ucyhkZWZhdWx0cywgaXRlbSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uZGVmYXVsdHNcbiAgfTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgIGNvbnN0IHZhbHVlID0gaXRlbVtrZXldO1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAoa2V5IGluIGRlZmF1bHRJY29uU2l6ZUN1c3RvbWlzYXRpb25zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgJiYgKHZhbHVlVHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZVR5cGUgPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09IHR5cGVvZiByZXN1bHRba2V5XSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBrZXkgPT09IFwicm90YXRlXCIgPyB2YWx1ZSAlIDQgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3Qgc2VwYXJhdG9yID0gL1tcXHMsXSsvO1xuZnVuY3Rpb24gZmxpcEZyb21TdHJpbmcoY3VzdG9tLCBmbGlwKSB7XG4gIGZsaXAuc3BsaXQoc2VwYXJhdG9yKS5mb3JFYWNoKChzdHIpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0ci50cmltKCk7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgY3VzdG9tLmhGbGlwID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgY3VzdG9tLnZGbGlwID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcm90YXRlRnJvbVN0cmluZyh2YWx1ZSwgZGVmYXVsdFZhbHVlID0gMCkge1xuICBjb25zdCB1bml0cyA9IHZhbHVlLnJlcGxhY2UoL14tP1swLTkuXSovLCBcIlwiKTtcbiAgZnVuY3Rpb24gY2xlYW51cCh2YWx1ZTIpIHtcbiAgICB3aGlsZSAodmFsdWUyIDwgMCkge1xuICAgICAgdmFsdWUyICs9IDQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTIgJSA0O1xuICB9XG4gIGlmICh1bml0cyA9PT0gXCJcIikge1xuICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4obnVtKSA/IDAgOiBjbGVhbnVwKG51bSk7XG4gIH0gZWxzZSBpZiAodW5pdHMgIT09IHZhbHVlKSB7XG4gICAgbGV0IHNwbGl0ID0gMDtcbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBzcGxpdCA9IDI1O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWdcIjpcbiAgICAgICAgc3BsaXQgPSA5MDtcbiAgICB9XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBsZXQgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGggLSB1bml0cy5sZW5ndGgpKTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgbnVtID0gbnVtIC8gc3BsaXQ7XG4gICAgICByZXR1cm4gbnVtICUgMSA9PT0gMCA/IGNsZWFudXAobnVtKSA6IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIGljb25Ub0hUTUwoYm9keSwgYXR0cmlidXRlcykge1xuICBsZXQgcmVuZGVyQXR0cmlic0hUTUwgPSBib2R5LmluZGV4T2YoXCJ4bGluazpcIikgPT09IC0xID8gXCJcIiA6ICcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCInO1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgIHJlbmRlckF0dHJpYnNIVE1MICs9IFwiIFwiICsgYXR0ciArICc9XCInICsgYXR0cmlidXRlc1thdHRyXSArICdcIic7XG4gIH1cbiAgcmV0dXJuICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIicgKyByZW5kZXJBdHRyaWJzSFRNTCArIFwiPlwiICsgYm9keSArIFwiPC9zdmc+XCI7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVNWR2ZvclVSTChzdmcpIHtcbiAgcmV0dXJuIHN2Zy5yZXBsYWNlKC9cIi9nLCBcIidcIikucmVwbGFjZSgvJS9nLCBcIiUyNVwiKS5yZXBsYWNlKC8jL2csIFwiJTIzXCIpLnJlcGxhY2UoLzwvZywgXCIlM0NcIikucmVwbGFjZSgvPi9nLCBcIiUzRVwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHN2Z1RvRGF0YShzdmcpIHtcbiAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sLFwiICsgZW5jb2RlU1ZHZm9yVVJMKHN2Zyk7XG59XG5mdW5jdGlvbiBzdmdUb1VSTChzdmcpIHtcbiAgcmV0dXJuICd1cmwoXCInICsgc3ZnVG9EYXRhKHN2ZykgKyAnXCIpJztcbn1cblxubGV0IHBvbGljeTtcbmZ1bmN0aW9uIGNyZWF0ZVBvbGljeSgpIHtcbiAgdHJ5IHtcbiAgICBwb2xpY3kgPSB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcImljb25pZnlcIiwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICBjcmVhdGVIVE1MOiAocykgPT4gc1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwb2xpY3kgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhblVwSW5uZXJIVE1MKGh0bWwpIHtcbiAgaWYgKHBvbGljeSA9PT0gdm9pZCAwKSB7XG4gICAgY3JlYXRlUG9saWN5KCk7XG4gIH1cbiAgcmV0dXJuIHBvbGljeSA/IHBvbGljeS5jcmVhdGVIVE1MKGh0bWwpIDogaHRtbDtcbn1cblxuY29uc3QgZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMsXG4gICAgaW5saW5lOiBmYWxzZSxcbn07XG5cbi8qKlxuICogRGVmYXVsdCBTVkcgYXR0cmlidXRlc1xuICovXG5jb25zdCBzdmdEZWZhdWx0cyA9IHtcbiAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICd4bWxuc1hsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgJ3JvbGUnOiAnaW1nJyxcbn07XG4vKipcbiAqIFN0eWxlIG1vZGVzXG4gKi9cbmNvbnN0IGNvbW1vblByb3BzID0ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxufTtcbmNvbnN0IG1vbm90b25lUHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbn07XG5jb25zdCBjb2xvcmVkUHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxufTtcbi8vIER5bmFtaWNhbGx5IGFkZCBjb21tb24gcHJvcHMgdG8gdmFyaWFibGVzIGFib3ZlXG5jb25zdCBwcm9wc1RvQWRkID0ge1xuICAgIEltYWdlOiAndmFyKC0tc3ZnKScsXG4gICAgUmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAgICBTaXplOiAnMTAwJSAxMDAlJyxcbn07XG5jb25zdCBwcm9wc1RvQWRkVG8gPSB7XG4gICAgV2Via2l0TWFzazogbW9ub3RvbmVQcm9wcyxcbiAgICBtYXNrOiBtb25vdG9uZVByb3BzLFxuICAgIGJhY2tncm91bmQ6IGNvbG9yZWRQcm9wcyxcbn07XG5mb3IgKGNvbnN0IHByZWZpeCBpbiBwcm9wc1RvQWRkVG8pIHtcbiAgICBjb25zdCBsaXN0ID0gcHJvcHNUb0FkZFRvW3ByZWZpeF07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzVG9BZGQpIHtcbiAgICAgICAgbGlzdFtwcmVmaXggKyBwcm9wXSA9IHByb3BzVG9BZGRbcHJvcF07XG4gICAgfVxufVxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgY3VzdG9taXNhdGlvbnMgZm9yIGlubGluZSBpY29uXG4gKi9cbmNvbnN0IGlubGluZURlZmF1bHRzID0ge1xuICAgIC4uLmRlZmF1bHRFeHRlbmRlZEljb25DdXN0b21pc2F0aW9ucyxcbiAgICBpbmxpbmU6IHRydWUsXG59O1xuLyoqXG4gKiBGaXggc2l6ZTogYWRkICdweCcgdG8gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBmaXhTaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgKHZhbHVlLm1hdGNoKC9eWy0wLTkuXSskLykgPyAncHgnIDogJycpO1xufVxuLyoqXG4gKiBSZW5kZXIgaWNvblxuICovXG5jb25zdCByZW5kZXIgPSAoXG4vLyBJY29uIG11c3QgYmUgdmFsaWRhdGVkIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb25cbmljb24sIFxuLy8gUGFydGlhbCBwcm9wZXJ0aWVzXG5wcm9wcywgXG4vLyBJY29uIG5hbWVcbm5hbWUpID0+IHtcbiAgICAvLyBHZXQgZGVmYXVsdCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZGVmYXVsdFByb3BzID0gcHJvcHMuaW5saW5lXG4gICAgICAgID8gaW5saW5lRGVmYXVsdHNcbiAgICAgICAgOiBkZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnM7XG4gICAgLy8gR2V0IGFsbCBjdXN0b21pc2F0aW9uc1xuICAgIGNvbnN0IGN1c3RvbWlzYXRpb25zID0gbWVyZ2VDdXN0b21pc2F0aW9ucyhkZWZhdWx0UHJvcHMsIHByb3BzKTtcbiAgICAvLyBDaGVjayBtb2RlXG4gICAgY29uc3QgbW9kZSA9IHByb3BzLm1vZGUgfHwgJ3N2Zyc7XG4gICAgLy8gQ3JlYXRlIHN0eWxlXG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcbiAgICBjb25zdCBjdXN0b21TdHlsZSA9IHByb3BzLnN0eWxlIHx8IHt9O1xuICAgIC8vIENyZWF0ZSBTVkcgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICBjb25zdCBjb21wb25lbnRQcm9wcyA9IHtcbiAgICAgICAgLi4uKG1vZGUgPT09ICdzdmcnID8gc3ZnRGVmYXVsdHMgOiB7fSksXG4gICAgfTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBjb25zdCBpY29uTmFtZSA9IHN0cmluZ1RvSWNvbihuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChpY29uTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsnaWNvbmlmeSddO1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICAgICAgJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgICAgICAncHJlZml4JyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWNvbk5hbWVbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdpY29uaWZ5LS0nICsgaWNvbk5hbWVbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudFByb3BzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdldCBlbGVtZW50IHByb3BlcnRpZXNcbiAgICBmb3IgKGxldCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgdG8gaWdub3JlXG4gICAgICAgICAgICBjYXNlICdpY29uJzpcbiAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICAgIGNhc2UgJ29uTG9hZCc6XG4gICAgICAgICAgICBjYXNlICdtb2RlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Nzcic6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIHJlZlxuICAgICAgICAgICAgY2FzZSAnX3JlZic6XG4gICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHMucmVmID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBNZXJnZSBjbGFzcyBuYW1lc1xuICAgICAgICAgICAgY2FzZSAnY2xhc3NOYW1lJzpcbiAgICAgICAgICAgICAgICBjb21wb25lbnRQcm9wc1trZXldID1cbiAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudFByb3BzW2tleV0gPyBjb21wb25lbnRQcm9wc1trZXldICsgJyAnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjYXNlICdpbmxpbmUnOlxuICAgICAgICAgICAgY2FzZSAnaEZsaXAnOlxuICAgICAgICAgICAgY2FzZSAndkZsaXAnOlxuICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gRmxpcCBhcyBzdHJpbmc6ICdob3Jpem9udGFsLHZlcnRpY2FsJ1xuICAgICAgICAgICAgY2FzZSAnZmxpcCc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxpcEZyb21TdHJpbmcoY3VzdG9taXNhdGlvbnMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb2xvcjogY29weSB0byBzdHlsZVxuICAgICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgICAgIHN0eWxlLmNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcyBzdHJpbmdcbiAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9taXNhdGlvbnNba2V5XSA9IHJvdGF0ZUZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYXJpYS1oaWRkZW5cbiAgICAgICAgICAgIGNhc2UgJ2FyaWFIaWRkZW4nOlxuICAgICAgICAgICAgY2FzZSAnYXJpYS1oaWRkZW4nOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRQcm9wc1snYXJpYS1oaWRkZW4nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb3B5IG1pc3NpbmcgcHJvcGVydHkgaWYgaXQgZG9lcyBub3QgZXhpc3QgaW4gY3VzdG9taXNhdGlvbnNcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRQcm9wc1trZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBpY29uXG4gICAgY29uc3QgaXRlbSA9IGljb25Ub1NWRyhpY29uLCBjdXN0b21pc2F0aW9ucyk7XG4gICAgY29uc3QgcmVuZGVyQXR0cmlicyA9IGl0ZW0uYXR0cmlidXRlcztcbiAgICAvLyBJbmxpbmUgZGlzcGxheVxuICAgIGlmIChjdXN0b21pc2F0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgc3R5bGUudmVydGljYWxBbGlnbiA9ICctMC4xMjVlbSc7XG4gICAgfVxuICAgIGlmIChtb2RlID09PSAnc3ZnJykge1xuICAgICAgICAvLyBBZGQgc3R5bGVcbiAgICAgICAgY29tcG9uZW50UHJvcHMuc3R5bGUgPSB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIC4uLmN1c3RvbVN0eWxlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBZGQgaWNvbiBzdHVmZlxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbXBvbmVudFByb3BzLCByZW5kZXJBdHRyaWJzKTtcbiAgICAgICAgLy8gQ291bnRlciBmb3IgaWRzIGJhc2VkIG9uIFwiaWRcIiBwcm9wZXJ0eSB0byByZW5kZXIgaWNvbnMgY29uc2lzdGVudGx5IG9uIHNlcnZlciBhbmQgY2xpZW50XG4gICAgICAgIGxldCBsb2NhbENvdW50ZXIgPSAwO1xuICAgICAgICBsZXQgaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgJy0nIHRvICdfJyB0byBhdm9pZCBlcnJvcnMgaW4gYW5pbWF0aW9uc1xuICAgICAgICAgICAgaWQgPSBpZC5yZXBsYWNlKC8tL2csICdfJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGljb24gc3R1ZmZcbiAgICAgICAgY29tcG9uZW50UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7XG4gICAgICAgICAgICBfX2h0bWw6IGNsZWFuVXBJbm5lckhUTUwocmVwbGFjZUlEcyhpdGVtLmJvZHksIGlkID8gKCkgPT4gaWQgKyAnSUQnICsgbG9jYWxDb3VudGVyKysgOiAnaWNvbmlmeVJlYWN0JykpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnc3ZnJywgY29tcG9uZW50UHJvcHMpO1xuICAgIH1cbiAgICAvLyBSZW5kZXIgPHNwYW4+IHdpdGggc3R5bGVcbiAgICBjb25zdCB7IGJvZHksIHdpZHRoLCBoZWlnaHQgfSA9IGljb247XG4gICAgY29uc3QgdXNlTWFzayA9IG1vZGUgPT09ICdtYXNrJyB8fFxuICAgICAgICAobW9kZSA9PT0gJ2JnJyA/IGZhbHNlIDogYm9keS5pbmRleE9mKCdjdXJyZW50Q29sb3InKSAhPT0gLTEpO1xuICAgIC8vIEdlbmVyYXRlIFNWR1xuICAgIGNvbnN0IGh0bWwgPSBpY29uVG9IVE1MKGJvZHksIHtcbiAgICAgICAgLi4ucmVuZGVyQXR0cmlicyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJycsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJycsXG4gICAgfSk7XG4gICAgLy8gR2VuZXJhdGUgc3R5bGVcbiAgICBjb21wb25lbnRQcm9wcy5zdHlsZSA9IHtcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICctLXN2Zyc6IHN2Z1RvVVJMKGh0bWwpLFxuICAgICAgICAnd2lkdGgnOiBmaXhTaXplKHJlbmRlckF0dHJpYnMud2lkdGgpLFxuICAgICAgICAnaGVpZ2h0JzogZml4U2l6ZShyZW5kZXJBdHRyaWJzLmhlaWdodCksXG4gICAgICAgIC4uLmNvbW1vblByb3BzLFxuICAgICAgICAuLi4odXNlTWFzayA/IG1vbm90b25lUHJvcHMgOiBjb2xvcmVkUHJvcHMpLFxuICAgICAgICAuLi5jdXN0b21TdHlsZSxcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdzcGFuJywgY29tcG9uZW50UHJvcHMpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgY2FjaGVcbiAqXG4gKiBAZGVwcmVjYXRlZCBObyBsb25nZXIgdXNlZFxuICovXG5mdW5jdGlvbiBlbmFibGVDYWNoZShzdG9yYWdlKSB7XG4gICAgLy9cbn1cbi8qKlxuICogRGlzYWJsZSBjYWNoZVxuICpcbiAqIEBkZXByZWNhdGVkIE5vIGxvbmdlciB1c2VkXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVDYWNoZShzdG9yYWdlKSB7XG4gICAgLy9cbn1cbi8qKlxuICogSW5pdGlhbGlzZSBzdHVmZlxuICovXG4vLyBFbmFibGUgc2hvcnQgbmFtZXNcbmFsbG93U2ltcGxlTmFtZXModHJ1ZSk7XG4vLyBTZXQgQVBJIG1vZHVsZVxuc2V0QVBJTW9kdWxlKCcnLCBmZXRjaEFQSU1vZHVsZSk7XG4vKipcbiAqIEJyb3dzZXIgc3R1ZmZcbiAqL1xuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBfd2luZG93ID0gd2luZG93O1xuICAgIC8vIExvYWQgaWNvbnMgZnJvbSBnbG9iYWwgXCJJY29uaWZ5UHJlbG9hZFwiXG4gICAgaWYgKF93aW5kb3cuSWNvbmlmeVByZWxvYWQgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBwcmVsb2FkID0gX3dpbmRvdy5JY29uaWZ5UHJlbG9hZDtcbiAgICAgICAgY29uc3QgZXJyID0gJ0ludmFsaWQgSWNvbmlmeVByZWxvYWQgc3ludGF4Lic7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlbG9hZCA9PT0gJ29iamVjdCcgJiYgcHJlbG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgKHByZWxvYWQgaW5zdGFuY2VvZiBBcnJheSA/IHByZWxvYWQgOiBbcHJlbG9hZF0pLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0ZW0gaXMgYW4gb2JqZWN0IGFuZCBub3QgbnVsbC9hcnJheVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yICdpY29ucycgYW5kICdwcmVmaXgnXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbS5pY29ucyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLnByZWZpeCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBpY29uIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgIWFkZENvbGxlY3Rpb24oaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0IEFQSSBmcm9tIGdsb2JhbCBcIkljb25pZnlQcm92aWRlcnNcIlxuICAgIGlmIChfd2luZG93Lkljb25pZnlQcm92aWRlcnMgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBwcm92aWRlcnMgPSBfd2luZG93Lkljb25pZnlQcm92aWRlcnM7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJzID09PSAnb2JqZWN0JyAmJiBwcm92aWRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSAnSWNvbmlmeVByb3ZpZGVyc1snICsga2V5ICsgJ10gaXMgaW52YWxpZC4nO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvdmlkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhdmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnJlc291cmNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFkZEFQSVByb3ZpZGVyKGtleSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIEljb25Db21wb25lbnQocHJvcHMpIHtcbiAgICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZSghIXByb3BzLnNzcik7XG4gICAgY29uc3QgW2Fib3J0LCBzZXRBYm9ydF0gPSB1c2VTdGF0ZSh7fSk7XG4gICAgLy8gR2V0IGluaXRpYWwgc3RhdGVcbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUobW91bnRlZCkge1xuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHByb3BzLmljb247XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWNvbiBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25EYXRhKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKGdldEluaXRpYWxTdGF0ZSghIXByb3BzLnNzcikpO1xuICAgIC8vIENhbmNlbCBsb2FkaW5nXG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBhYm9ydC5jYWxsYmFjaztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgc2V0QWJvcnQoe30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoYW5nZSBzdGF0ZSBpZiBpdCBpcyBkaWZmZXJlbnRcbiAgICBmdW5jdGlvbiBjaGFuZ2VTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoc3RhdGUpICE9PSBKU09OLnN0cmluZ2lmeShuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwcm9wcy5pY29uO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBJY29uIGFzIG9iamVjdFxuICAgICAgICAgICAgY2hhbmdlU3RhdGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIGRhdGE6IG5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXcgaWNvbiBvciBnb3QgaWNvbiBkYXRhXG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRJY29uRGF0YShuYW1lKTtcbiAgICAgICAgaWYgKGNoYW5nZVN0YXRlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgaWNvbiwgdXBkYXRlIHN0YXRlIHdoZW4gZG9uZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gbG9hZEljb25zKFtuYW1lXSwgdXBkYXRlU3RhdGUpO1xuICAgICAgICAgICAgICAgIHNldEFib3J0KHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gSWNvbiBkYXRhIGlzIGF2YWlsYWJsZTogdHJpZ2dlciBvbkxvYWQgY2FsbGJhY2sgaWYgcHJlc2VudFxuICAgICAgICAgICAgICAgIChfYSA9IHByb3BzLm9uTG9hZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvcHMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1vdW50ZWQgc3RhdGUsIGNsZWFudXAgZm9yIGxvYWRlclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0sIFtdKTtcbiAgICAvLyBJY29uIGNoYW5nZWQgb3IgY29tcG9uZW50IG1vdW50ZWRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sIFtwcm9wcy5pY29uLCBtb3VudGVkXSk7XG4gICAgLy8gUmVuZGVyIGljb25cbiAgICBjb25zdCB7IG5hbWUsIGRhdGEgfSA9IHN0YXRlO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgID8gcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgIDogcHJvcHMuZmFsbGJhY2tcbiAgICAgICAgICAgICAgICA/IHByb3BzLmZhbGxiYWNrXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVFbGVtZW50KCdzcGFuJywge30pO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyKHtcbiAgICAgICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAgICAgLi4uZGF0YSxcbiAgICB9LCBwcm9wcywgbmFtZSk7XG59XG4vKipcbiAqIEJsb2NrIGljb25cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBDb21wb25lbnQgcHJvcGVydGllc1xuICovXG5jb25zdCBJY29uID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gSWNvbkNvbXBvbmVudCh7XG4gICAgLi4ucHJvcHMsXG4gICAgX3JlZjogcmVmLFxufSkpO1xuLyoqXG4gKiBJbmxpbmUgaWNvbiAoaGFzIG5lZ2F0aXZlIHZlcnRpY2FsQWxpZ24gdGhhdCBtYWtlcyBpdCBiZWhhdmUgbGlrZSBpY29uIGZvbnQpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gQ29tcG9uZW50IHByb3BlcnRpZXNcbiAqL1xuY29uc3QgSW5saW5lSWNvbiA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IEljb25Db21wb25lbnQoe1xuICAgIGlubGluZTogdHJ1ZSxcbiAgICAuLi5wcm9wcyxcbiAgICBfcmVmOiByZWYsXG59KSk7XG4vKipcbiAqIEludGVybmFsIEFQSVxuICovXG5jb25zdCBfYXBpID0ge1xuICAgIGdldEFQSUNvbmZpZyxcbiAgICBzZXRBUElNb2R1bGUsXG4gICAgc2VuZEFQSVF1ZXJ5LFxuICAgIHNldEZldGNoLFxuICAgIGdldEZldGNoLFxuICAgIGxpc3RBUElQcm92aWRlcnMsXG59O1xuXG5leHBvcnQgeyBJY29uLCBJbmxpbmVJY29uLCBfYXBpLCBhZGRBUElQcm92aWRlciwgYWRkQ29sbGVjdGlvbiwgYWRkSWNvbiwgaWNvblRvU1ZHIGFzIGJ1aWxkSWNvbiwgY2FsY3VsYXRlU2l6ZSwgZGlzYWJsZUNhY2hlLCBlbmFibGVDYWNoZSwgZ2V0SWNvbiwgaWNvbkxvYWRlZCBhcyBpY29uRXhpc3RzLCBpY29uTG9hZGVkLCBsaXN0SWNvbnMsIGxvYWRJY29uLCBsb2FkSWNvbnMsIHJlcGxhY2VJRHMsIHNldEN1c3RvbUljb25Mb2FkZXIsIHNldEN1c3RvbUljb25zTG9hZGVyIH07XG4iXSwibmFtZXMiOlsiY3JlYXRlRWxlbWVudCIsImZvcndhcmRSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImRlZmF1bHRJY29uRGltZW5zaW9ucyIsIk9iamVjdCIsImZyZWV6ZSIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsImhlaWdodCIsImRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zIiwicm90YXRlIiwidkZsaXAiLCJoRmxpcCIsImRlZmF1bHRJY29uUHJvcHMiLCJkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMiLCJib2R5IiwiaGlkZGVuIiwibWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zIiwib2JqMSIsIm9iajIiLCJyZXN1bHQiLCJtZXJnZUljb25EYXRhIiwicGFyZW50IiwiY2hpbGQiLCJrZXkiLCJnZXRJY29uc1RyZWUiLCJkYXRhIiwibmFtZXMiLCJpY29ucyIsImFsaWFzZXMiLCJjcmVhdGUiLCJyZXNvbHZlZCIsInJlc29sdmUiLCJuYW1lIiwidmFsdWUiLCJjb25jYXQiLCJrZXlzIiwiZm9yRWFjaCIsImludGVybmFsR2V0SWNvbkRhdGEiLCJ0cmVlIiwiY3VycmVudFByb3BzIiwicGFyc2UiLCJuYW1lMiIsInBhcnNlSWNvblNldCIsImNhbGxiYWNrIiwibm90X2ZvdW5kIiwiQXJyYXkiLCJwdXNoIiwiaXRlbSIsIm9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cyIsInByb3ZpZGVyIiwiY2hlY2tPcHRpb25hbFByb3BzIiwiZGVmYXVsdHMiLCJwcm9wIiwicXVpY2tseVZhbGlkYXRlSWNvblNldCIsIm9iaiIsInByZWZpeCIsImljb24iLCJtYXRjaEljb25OYW1lIiwic3RyaW5nVG9JY29uIiwidmFsaWRhdGUiLCJhbGxvd1NpbXBsZU5hbWUiLCJjb2xvblNlcGFyYXRlZCIsInNwbGl0Iiwic2xpY2UiLCJsZW5ndGgiLCJzaGlmdCIsInBvcCIsInZhbGlkYXRlSWNvbk5hbWUiLCJkYXNoU2VwYXJhdGVkIiwiam9pbiIsImRhdGFTdG9yYWdlIiwibmV3U3RvcmFnZSIsIm1pc3NpbmciLCJTZXQiLCJnZXRTdG9yYWdlIiwicHJvdmlkZXJTdG9yYWdlIiwiYWRkSWNvblNldCIsInN0b3JhZ2UiLCJhZGQiLCJhZGRJY29uVG9TdG9yYWdlIiwiZXJyIiwibGlzdEljb25zIiwiYWxsSWNvbnMiLCJwcm92aWRlcnMiLCJwcm92aWRlcjIiLCJwcmVmaXhlcyIsInByZWZpeDIiLCJtYXAiLCJzaW1wbGVOYW1lcyIsImFsbG93U2ltcGxlTmFtZXMiLCJhbGxvdyIsImdldEljb25EYXRhIiwiaWNvbk5hbWUiLCJoYXMiLCJhZGRJY29uIiwiYWRkQ29sbGVjdGlvbiIsImFkZGVkIiwiaWNvbkxvYWRlZCIsImdldEljb24iLCJkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyIsImRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMiLCJ1bml0c1NwbGl0IiwidW5pdHNUZXN0IiwiY2FsY3VsYXRlU2l6ZSIsInNpemUiLCJyYXRpbyIsInByZWNpc2lvbiIsIk1hdGgiLCJjZWlsIiwib2xkUGFydHMiLCJuZXdQYXJ0cyIsImNvZGUiLCJpc051bWJlciIsInRlc3QiLCJudW0iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJzcGxpdFNWR0RlZnMiLCJjb250ZW50IiwidGFnIiwiZGVmcyIsImluZGV4IiwiaW5kZXhPZiIsInN0YXJ0IiwiZW5kIiwiZW5kRW5kIiwidHJpbSIsIm1lcmdlRGVmc0FuZENvbnRlbnQiLCJ3cmFwU1ZHQ29udGVudCIsImlzVW5zZXRLZXl3b3JkIiwiaWNvblRvU1ZHIiwiY3VzdG9taXNhdGlvbnMiLCJmdWxsSWNvbiIsImZ1bGxDdXN0b21pc2F0aW9ucyIsImJveCIsInByb3BzIiwidHJhbnNmb3JtYXRpb25zIiwicm90YXRpb24iLCJ0b1N0cmluZyIsInRlbXBWYWx1ZSIsImZsb29yIiwidW5zaGlmdCIsImN1c3RvbWlzYXRpb25zV2lkdGgiLCJjdXN0b21pc2F0aW9uc0hlaWdodCIsImJveFdpZHRoIiwiYm94SGVpZ2h0IiwiYXR0cmlidXRlcyIsInNldEF0dHIiLCJ2aWV3Qm94IiwicmVnZXgiLCJyYW5kb21QcmVmaXgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwiY291bnRlciIsInJlcGxhY2VJRHMiLCJpZHMiLCJtYXRjaCIsImV4ZWMiLCJzdWZmaXgiLCJpZCIsIm5ld0lEIiwiZXNjYXBlZElEIiwicmVwbGFjZSIsIlJlZ0V4cCIsInNldEFQSU1vZHVsZSIsImdldEFQSU1vZHVsZSIsImNyZWF0ZUFQSUNvbmZpZyIsInNvdXJjZSIsInJlc291cmNlcyIsInBhdGgiLCJtYXhVUkwiLCJ0aW1lb3V0IiwiZGF0YUFmdGVyVGltZW91dCIsImNvbmZpZ1N0b3JhZ2UiLCJmYWxsQmFja0FQSVNvdXJjZXMiLCJmYWxsQmFja0FQSSIsImFkZEFQSVByb3ZpZGVyIiwiY3VzdG9tQ29uZmlnIiwiY29uZmlnIiwiZ2V0QVBJQ29uZmlnIiwibGlzdEFQSVByb3ZpZGVycyIsImRldGVjdEZldGNoIiwiZmV0Y2giLCJmZXRjaE1vZHVsZSIsInNldEZldGNoIiwiZmV0Y2gyIiwiZ2V0RmV0Y2giLCJjYWxjdWxhdGVNYXhMZW5ndGgiLCJtYXhIb3N0TGVuZ3RoIiwiaG9zdCIsIm1heCIsInVybCIsInNob3VsZEFib3J0Iiwic3RhdHVzIiwicHJlcGFyZSIsInJlc3VsdHMiLCJtYXhMZW5ndGgiLCJ0eXBlIiwiZ2V0UGF0aCIsInNlbmQiLCJwYXJhbXMiLCJpY29uc0xpc3QiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ1cmkiLCJkZWZhdWx0RXJyb3IiLCJ0aGVuIiwicmVzcG9uc2UiLCJzZXRUaW1lb3V0IiwianNvbiIsImNhdGNoIiwiZmV0Y2hBUElNb2R1bGUiLCJzb3J0SWNvbnMiLCJsb2FkZWQiLCJwZW5kaW5nIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImxhc3RJY29uIiwibG9jYWxTdG9yYWdlIiwibGlzdCIsInJlbW92ZUNhbGxiYWNrIiwic3RvcmFnZXMiLCJpdGVtcyIsImxvYWRlckNhbGxiYWNrcyIsImZpbHRlciIsInJvdyIsInVwZGF0ZUNhbGxiYWNrcyIsInBlbmRpbmdDYWxsYmFja3NGbGFnIiwiaGFzUGVuZGluZyIsIm9sZExlbmd0aCIsImFib3J0IiwiaWRDb3VudGVyIiwic3RvcmVDYWxsYmFjayIsInBlbmRpbmdTb3VyY2VzIiwiYmluZCIsImxpc3RUb0ljb25zIiwiZGVmYXVsdENvbmZpZyIsInNlbmRRdWVyeSIsInBheWxvYWQiLCJxdWVyeSIsImRvbmUiLCJyZXNvdXJjZXNDb3VudCIsInN0YXJ0SW5kZXgiLCJuZXh0SW5kZXgiLCJzdGFydFRpbWUiLCJxdWVyaWVzU2VudCIsImxhc3RFcnJvciIsInRpbWVyIiwicXVldWUiLCJkb25lQ2FsbGJhY2tzIiwicmVzZXRUaW1lciIsImNsZWFyVGltZW91dCIsInN1YnNjcmliZSIsIm92ZXJ3cml0ZSIsImdldFF1ZXJ5U3RhdHVzIiwicXVlcmllc1BlbmRpbmciLCJmYWlsUXVlcnkiLCJjbGVhclF1ZXVlIiwibW9kdWxlUmVzcG9uc2UiLCJpc0Vycm9yIiwicXVldWVkIiwiZXhlY05leHQiLCJyZXNvdXJjZSIsInN0YXR1czIiLCJpbml0UmVkdW5kYW5jeSIsImNmZyIsInF1ZXJpZXMiLCJjbGVhbnVwIiwicXVlcnlDYWxsYmFjayIsImRvbmVDYWxsYmFjayIsInF1ZXJ5MiIsImVycm9yIiwiZmluZCIsImluc3RhbmNlIiwic2V0SW5kZXgiLCJnZXRJbmRleCIsImVtcHR5Q2FsbGJhY2skMSIsInJlZHVuZGFuY3lDYWNoZSIsImdldFJlZHVuZGFuY3lDYWNoZSIsInJlZHVuZGFuY3kiLCJjYWNoZWRSZXVuZGFuY3kiLCJzZW5kQVBJUXVlcnkiLCJ0YXJnZXQiLCJhcGkiLCJjYWNoZWQiLCJtb2R1bGVLZXkiLCJlbXB0eUNhbGxiYWNrIiwibG9hZGVkTmV3SWNvbnMiLCJpY29uc0xvYWRlckZsYWciLCJjaGVja0ljb25OYW1lc0ZvckFQSSIsInZhbGlkIiwiaW52YWxpZCIsInBhcnNlTG9hZGVyUmVzcG9uc2UiLCJjaGVja01pc3NpbmciLCJwZW5kaW5nSWNvbnMiLCJkZWxldGUiLCJwYXJzZWQiLCJjb25zb2xlIiwicGFyc2VQb3NzaWJseUFzeW5jUmVzcG9uc2UiLCJQcm9taXNlIiwibG9hZE5ld0ljb25zIiwiaWNvbnNUb0xvYWQiLCJpY29uc1F1ZXVlRmxhZyIsImljb25zMiIsImN1c3RvbUljb25Mb2FkZXIiLCJsb2FkSWNvbiIsImxvYWRJY29ucyIsImljb25TZXQiLCJjbGVhbmVkSWNvbnMiLCJzb3J0ZWRJY29ucyIsImNhbGxDYWxsYmFjayIsIm5ld0ljb25zIiwic291cmNlcyIsImxhc3RQcm92aWRlciIsImxhc3RQcmVmaXgiLCJwcm92aWRlck5ld0ljb25zIiwicGVuZGluZ1F1ZXVlIiwiZnVsZmlsbCIsInJlamVjdCIsImljb25PYmoiLCJzZXRDdXN0b21JY29uc0xvYWRlciIsImxvYWRlciIsInNldEN1c3RvbUljb25Mb2FkZXIiLCJtZXJnZUN1c3RvbWlzYXRpb25zIiwidmFsdWVUeXBlIiwic2VwYXJhdG9yIiwiZmxpcEZyb21TdHJpbmciLCJjdXN0b20iLCJmbGlwIiwic3RyIiwicm90YXRlRnJvbVN0cmluZyIsImRlZmF1bHRWYWx1ZSIsInVuaXRzIiwidmFsdWUyIiwicGFyc2VJbnQiLCJpY29uVG9IVE1MIiwicmVuZGVyQXR0cmlic0hUTUwiLCJhdHRyIiwiZW5jb2RlU1ZHZm9yVVJMIiwic3ZnIiwic3ZnVG9EYXRhIiwic3ZnVG9VUkwiLCJwb2xpY3kiLCJjcmVhdGVQb2xpY3kiLCJ3aW5kb3ciLCJ0cnVzdGVkVHlwZXMiLCJjcmVhdGVIVE1MIiwicyIsImNsZWFuVXBJbm5lckhUTUwiLCJodG1sIiwiZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zIiwiaW5saW5lIiwic3ZnRGVmYXVsdHMiLCJjb21tb25Qcm9wcyIsImRpc3BsYXkiLCJtb25vdG9uZVByb3BzIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3JlZFByb3BzIiwicHJvcHNUb0FkZCIsIkltYWdlIiwiUmVwZWF0IiwiU2l6ZSIsInByb3BzVG9BZGRUbyIsIldlYmtpdE1hc2siLCJtYXNrIiwiYmFja2dyb3VuZCIsImlubGluZURlZmF1bHRzIiwiZml4U2l6ZSIsInJlbmRlciIsImRlZmF1bHRQcm9wcyIsIm1vZGUiLCJzdHlsZSIsImN1c3RvbVN0eWxlIiwiY29tcG9uZW50UHJvcHMiLCJjbGFzc05hbWVzIiwiY2xhc3NOYW1lIiwicmVmIiwiY29sb3IiLCJyZW5kZXJBdHRyaWJzIiwidmVydGljYWxBbGlnbiIsImFzc2lnbiIsImxvY2FsQ291bnRlciIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwidXNlTWFzayIsImVuYWJsZUNhY2hlIiwiZGlzYWJsZUNhY2hlIiwiZG9jdW1lbnQiLCJfd2luZG93IiwiSWNvbmlmeVByZWxvYWQiLCJwcmVsb2FkIiwiZSIsIkljb25pZnlQcm92aWRlcnMiLCJJY29uQ29tcG9uZW50IiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJzc3IiLCJzZXRBYm9ydCIsImdldEluaXRpYWxTdGF0ZSIsInN0YXRlIiwic2V0U3RhdGUiLCJjaGFuZ2VTdGF0ZSIsIm5ld1N0YXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZGF0ZVN0YXRlIiwiX2EiLCJ1bmRlZmluZWQiLCJvbkxvYWQiLCJjYWxsIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsIkljb24iLCJfcmVmIiwiSW5saW5lSWNvbiIsIl9hcGkiLCJidWlsZEljb24iLCJpY29uRXhpc3RzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@iconify/react/dist/iconify.js\n");

/***/ })

};
;